# 1. 注解和反射

## 1. 注解

## 2. 反射

# 2. 多线程

## 1. 线程基础

 ### 1. 实现方式

1. 继承Thread类

   - 子类继承Thread类具备多线程能力

   - 启动线程：子类对象.start()

     ```java
       testThread1.start();
     ```

   - <font color="red">不建议使用：避免单继承局限性</font>

2. 实现Runnable接口

   - 实现接口Runnable具有多线程能力

   - 启动线程：传入目标对象+Thread对象.start()

     ```java
     new Thread(testThread3).start();
     ```

   - 前期建议使用：灵活方便，同一个对象可以被多个线程使用

3. 实现Callable接口（拓展）

   - 实现Callable接口，需要返回值类型
   - 重写call方法，需要抛出异常
   - 四个步骤：创建执行服务->提交执行->获取结果->关闭服务
   - 优点：可以定义返回值，可以抛出异常
   - 缺点：复杂
   - 后期主要使用该方法



 ### 2. 静态代理

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实角色
- 优点：
  - 代理对象可以做很多真实对象做不了的事情
  - 真实对象专注自己的事情

 ### 3. Lambda表达式

- 函数式接口：如果一个接口只包含唯一一个抽象方法，那它就是一个函数式接口。对于函数式接口，我们可以用Lambda表达式来创建该接口的对象

  ```java
  love = a -> System.out.println("I love you-->" + a);
  ```
  

## 2. 线程状态

 ### 1. 线程的五个状态

1. 创建状态
2. 就绪状态
3. 阻塞状态
4. 运行状态
5. 死亡状态

 ### 2. 停止线程

- 不推荐使用stop()和destroy()方法（已弃用）
- 推荐让线程自己停下来，如设置一个标志位flag，当flag=false时，线程终止运行,或使用指定运行次数

 ### 3. 线程休眠

- sleep不会释放锁

 ### 4. 线程礼让

- 礼让线程：让当前正在执行的线程暂停，但不阻塞；即让线程从运行状态转化为就绪状态
- 礼让不一定成功，取决于CPU

 ### 5. Join

- Join合并线程，将此线程执行完毕后，再执行其他线程。该线程执行完毕前，其他线程阻塞，可以想象为插队

 ### 6. 线程优先级

- 线程调度按照优先级决定应该调度哪个线程来执行

- 优先级用数字表示，范围从1~10

  ```java
   //预定义常量
   Thread.MIN_PRIORITY = 1;
   Thread.MAX_PRIORITY = 10;
   Thread.NORM_PRIORITY = 5;
  ```

- 可以用getPriority()和setPriority()来获取和改变线程优先级

- 优先级只是参考，实际执行效果还是取决于CPU

 ### 7. 守护线程

- 线程分为用户进程和守护进程

- JVM必须确保用户进程执行完毕，而不用等待守护线程执行完毕

- 守护线程的例子：后台记录操作日志，监控内存，垃圾回收等

- 设置方法

  ```java
  thread.setDaemon(true);//默认为false表示用户线程
  ```

## 3. 线程同步

 ### 1. 并发

- 同一个对象被多个线程同时操作

### 2. 线程同步

- 处理多线程问题时，多个线程访问同一个对象，需要线程同步机制

- 线程同步其实是一种等待机制，多个需要同时访问此对象的线程进入这个<font color="red">对象的等待池</font>形成队列，等待前面的线程使用完毕，下个线程再使用

- 线程同步还需要锁：为保证数据在方法中被访问时的正确性，在访问时加入<font color="red">锁机制synchronized</font>，当一个线程获得对象的排他锁、独占资源时，其他线程必须等待，使用后释放锁即可

- 锁机制可能会导致以下问题
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起
  - 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置

### 3. 同步方法

  - synchronized方法控制对象的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行

    ```java
    public synchronized void method(){}
    ```

  - 缺点：synchronized方法会影响其效率

  - synchronized锁的对象为变化的量，依据实际问题会用到同步方法和同步块

### 4. 同步块

  - Obj称之为同步监视器

    - Obj可以是任何对象，推荐用共享资源作为同步监视器
    - 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是本身或Class

    ```java
    synchronized(Obj){}
    ```

  - 同步监视器执行过程

    1. 第一个线程访问，锁定同步监视器，执行其中的代码
    2. 第二个线程访问，发现同步监视器被锁定，无法访问
    3. 第一个线程访问完毕，解锁同步监视器
    4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问
    
  - JUC包里的线程安全类型

### 5. 死锁

  - 产生死锁的四个必要条件
    - 互斥
    - 请求与等待
    - 不可剥夺
    - 循环等待
  - 只需破坏四个条件中的一个或多个即可避免死锁

### 6. 锁

  - 通过显示定义同步锁对象来实现同步。同步锁使用Lock对象充当
  - java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问资源之前先获得Lock对象
  - ReentranLock(可重入锁)类实现了Lock，它拥有与synchroized相同的并发性和内存语义，在线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁
  - synchronized与Lock对比
    - Lock是显示锁（手动开启和关闭锁，**切记要关闭锁**），synchronized是隐式锁，出了作用域自动释放
    - Lock只有代码块锁，synchronized有代码块锁和方法锁
    - 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）
    - 优先使用顺序：Lock>同步代码块（已经进入方法体，分配了相应资源）>同步方法（在方法体之外）

## 4. 线程协作与通信

### 1. 生产者消费者模式

- 生产者和消费者共享同一个资源，并且生产者和消费者直接相互依赖，互为条件
- 在生产者消费者问题中，仅有synchronized是不够的
  - synchronized可阻止并发更新同一个共享资源，实现了同步
  - synchronized不能用来实现不同线程之间的消息传递（通信）
- 解决方法：
  - 建立一个缓冲区，生产者将产品放入，消费者将产品取出（管程法）
  - 设置一个标志位，true生产，false等待（信号灯法）

### 2. 线程通信问题的方法

- Java提供了几个方法解决线程直接的通信问题

  | 方法名 | 作用 |
  | :----: | :----: |
  |  wait()| 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 |
  | wait(long timeout) | 指定等待的毫秒数 |
  | notify() | 唤醒一个处于等待状态的线程 |
  | notifyAll() | 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 |
  
- 注意：以上均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException

## 5. 线程池

### 1. 线程池

- 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大
- 思路：提起创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁线程，实现重复利用，类似生活中的公共交通工具
- 好处：
  - 提供相应速度
  - 降低资源消耗
  - 便于线程管理

### 2. 使用线程池

- 线程池核心参数
  - corePoolSize：核心池的大小
  - maximumPoolSize：最大线程数
  - keepAliveTime：线程没有任务时最长保持多长时间后会终止
- 相关API：ExecutorService和Executors
  - ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
  - Exrcutors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池

# 3. 网络编程

## 1. 计算机网络概述

- ip，端口号：TCP和UDP使用两套不同的端口号，都是0~65535

  ```bash
  netstat -ano  #查看所有端口
  netstat -ano | findstr 8080  #查找指定端口
  tasklist | findstr 8696  #查看指定PID的进程
  ```

- 协议

## 2. TCP实现聊天

### 1. 客户端

1. 连接服务器Socket
2. 发送消息

### 2. 服务端

1. 建立服务的端口ServiceSocket
2. 等待用户连接accept()（阻塞式监听）
3. 接收用户消息



## 3. TCP实现文件上传

## 4. UDP

- UDP并没有严格的客户端服务端区分

## 5. URL

- 协议://ip:端口/项目名/资源

# 4.IO流

## 1. 文件

### 1. 文件

- 保存的数据

### 2. 文件流

- 文件再程序中是以流的形式来操作的

- 输入流：数据从数据源(文件)到程序(内存)的路径

  输出流：数据从程序(内存)到数据源(文件)的路径

## 2. IO流

### 1. IO流原理

- Java程序中，对于数据的输入/输出操作以流(stream)的方式进行
- Java.io包中提供了各种流的类和接口，用以获取不同种类的数据，并通过方法输入或输出数据

### 2. 流的分类

- 字节流：按8bit(一字节)为单位

  字符流：按字符为单位

- Java的IO流都是由一下4个抽象基类产生

  | 抽象基类 | 字节流 | 字符流 |
  | :----: | :----: |:----:|
  | 输入流 | InputStream | Reader |
  | 输出流 | OutputStream | Writer |

- 字符流是字符操作的，只能用于文本文件，其他文件可能会造成文件损坏

  使用字节流操作文本文件则可能造成乱码(拷贝时不会)

- 节点流：从一个特定的数据源读写数据，如FileReader、FileWriter

  处理流：也叫包装流，是连接已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter

- 处理流的优点：

  - 提高性能：可以增加缓冲来提供输入输出的效率
  - 操作便捷：提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便

### 3. 常见流

- 对象处理流：

  - 序列化和反序列化

  - 某个对象支持序列化机制，必须让其类是可序列化的，即该类必需实现Serialized(推荐使用，标记接口，内部无方法)或Externalizable两个接口中的任一个

  - 使用ObjectOutputStream、ObjectInputStream进行序列化、反序列化

  - static和transient修饰的成员默认不会被序列化，其他属性也可以通过transient关键字使其不被序列化

  - 序列化具备可继承性，即子类默认也会实现序列化

  - 可以添加serialVersionUID(序列化版本号)提供兼容性，添加后会被认为是版本修改而不是全新的类

    ```java
    private static final long serialVersionUID = 1L;
    ```

  - 反序列化时需要向下转型，反序列化时的类需要有访问权限

  - 反序列化的顺序要和序列化时一致

- 标准输入输出流

  |  | 编译类型 | 运行类型 | 默认设备 |
  | :--: | :----: | :----: | :----: |
  | System.in | InputStream | BufferedInputStream | 键盘 |
  | System.out | PrintStream | PrintStream | 显示器 |

- 转换流

  - InputStreamReader和OutputStreamWriter
  - 把字节流转换为字符流
  - 字符流不能指定编码，通过这种方式可以得到指定编码的字符流

- 打印流

  - PrintStream和PrintWriter
  - 打印流只有输出流没有输入流
  - PrintStream使用的是write()方法，默认情况下输出位置为标准输出
  - System.out.println();中的out就是System类中的一个PrintStream常量

## 3. Properties类

### 1. Properties配置文件

- 配置文件格式

  键=值

  键=值

- 键值对不需要有空格，值不需要使用引号，值的默认类型为String

### 2. Properties类常见方法

- load：加载配置文件键值对到Properties对象
- list：将数据显示到指定设备
- getProperties(key)：根据键获取值
- setProperties(key,value)：设置键值对到Properties对象
- store：将Properties对象存储到配置文件，使用字节流时有中文会保存为Unicode码

# 5. JVM基础

## 1. JVM探究

### 1. 常见面试题

- Java8虚拟机和之前的变化
- OOM，StackOverFlow
- JVM的常用调优参数
- 内存快照和Dump文件
- 类加载器

### 2. 常见概念

- JVM的位置、JVM的体系结构
- 类加载器
- 双亲委派机制、沙箱安全机制
- Native
- PC寄存器
- 方法区、栈(存地址)、堆(存地址对应的属性和值)
- 三种JVM
- 新生区、老年区、永久区
- 堆内存调优
- GC(垃圾回收)
- JMM(Java内存模型)

## 2. JVM的体系结构

- JVM的位置：JVM介于操作系统和Java程序之间
- JVM是用C写的
- 体系结构图 <img src="https://i.bmp.ovh/imgs/2022/01/cc59183ebe020510.png"  />
- 栈和PC都不会有垃圾，JVM调优在堆里调（方法区是特殊的堆）

## 3. JVM的组件

### 1. 类加载器

- 作用：加载Class文件

- 步骤

  ![](https://s3.bmp.ovh/imgs/2022/01/6a4f76a564b524ca.png)

- 类加载器的分级

  - JVM的类加载器
  - 启动类(根)加载器
  - 扩展类加载器
  - 应用程序(系统类)加载器


### 2. 双亲委派机制

- 运行类时会先从下往上找类加载器中的类，如果多个加载器中都有类，最后会执行的类是上级加载器中的类
- 作用：保证安全
- 步骤：
  1. 类加载器收到类加载的请求
  2. 将这个请求向上委托给父类加载器完成
  3. 启动加载器检查是否能够加载当前类，能加载就结束，否则抛出异常通知子加载器进行加载
  4. 子类加载器重复步骤3

### 3. 沙箱安全机制

- 将Java代码限定在JVM虚拟机特定的运行范围中，并且严格限制代码对本地系统资源的访问
- 沙箱的基本组件：
  - 字节码校验器：确保Java类文件遵顼Java语言规范，可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类
  - 类加载器：防止恶意代码区干涉善意代码；守护被信任的类库边界；将代码归入保护域，确定了代码可以进行哪些操作
  - 存储控制器：控制核心API对操作系统的存取权限，可以由用户指定控制策略
  - 安全管理器：核心API和操作系统间的主要接口，实现权限控制，比存储控制器优先级高
  - 安全软件包：java.security下的类及其扩展包下的类，允许用户为自己的应用增加新的安全特性，包括安全提供者、消息摘要、数字签名(KeyTools)、加密、鉴别等

### 4. Native

- native关键字表明超出了Java的作用范围，需要调用C语言库，会进入本地方法栈，调用本地方法接口JNI。以便融合不同编程语言，为Java使用
- Java诞生时C/C++横行，想要立足，必须能调用C/C++的程序，于是便专门在内存中开辟一块标记区域：Native Method Strack来登记Native方法
- 最终执行时，加载本地方法库中的方法需通过JNI

### 5. 程序计数器PC

- 每一个线程都有一个PC，是线程私有的，本质是一个指针，指向方法区的字节码
- 用来存储指向下一条指令的地址，也就是即将要执行的指令代码，以便执行引擎读取下一条指令
- 是一个非常小的内存地址，几乎可以不计

### 6. 方法区

- 方法区被所有线程共享，此区域属于共享区间
- 所有字段、方法字节码、接口以及一些特殊方法（如构造函数）也再次定义。简单说，所有定义的方法的信息都保存在该区域
- 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池也存放在方法区中，<font color="yellow">但实例变量存在堆内存中，和方法区无关</font>

### 7. 栈

- 栈内存，主管程序运行，生命周期和线程同步
- 线程结束，栈内存释放。对于栈来说，不存在垃圾回收
- 栈的内容：8大类型、对象引用、实例方法
- 栈运行原理：栈帧，一个方法产生一个栈帧，执行最上面的方法

### 8. 堆

- 一个JVM只有一个堆内存
- 堆内存的大小是可以调节的
- 类加载器读取类文件后，会把变量放在堆区
- 堆分为三个区域：
  - 新生区：又分为伊甸园区(类诞生和成长甚至死亡的地方，所有的对象都在这里new出来)和幸存者区(一般有两个，以0、1标识，0就是from、1是to，活过垃圾回收的会进入这里)
  - 养老区
  - 永久区(JDK8以后叫元空间)：常驻内存，用来存放JDK自身的Class对象、Interface元数据，存储的是Java运行时的一些环境或类信息。不存在垃圾回收，关闭虚拟机就会释放内存。使用的是物理机的内存，不是JVM的内存
- GC主要是在新生区和养老区
- 堆内存满了会报OOM，可以使用MAT和Jprofiler等分析Dump文件，快速定位内存泄漏

### 9. 三种JVM

- Sun HotSpot
- BEA JRockit
- IBM J9VM

### 10. GC及其常用算法

- GC两种类型：轻GC和重GC(全局GC)

- 常用算法：

  - 标记清除法

    ![](https://s3.bmp.ovh/imgs/2022/01/e9d6f1f54014ae16.png)

  - 标记压缩法

    ![](https://s3.bmp.ovh/imgs/2022/01/76a2b5d5c182905d.png)

  - 复制算法

    将存活的对象复制到to区，然后清空from区(谁是空的谁是to区，谁不是空的谁是from区)

  - 分代收集法

    分为新生代和老年代，新生代用复制算法，老年代用标记压缩法

  - 总结：

    - 内存使用次数：复制算法(一次)<标记清除法(两次)<标记压缩法(多次)
    - 内存整齐度：复制算法=标记压缩法>标记清除法
    - 内存利用率：标记压缩法=标记清除法>复制算法

# 6. JUC并发

## 1. JUC简介

### 1. 什么是JUC

- JUC是java.util .concurrent工具包的简称，这是一个处理线程的工具包

### 2. 回顾多线程

- Runnable：没有返回值，效率相对Callable较低
- 线程和进程：Java默认有两个进程(main和GC)

### 3. 并发和并行

- 并行：多个进程干同样的事(要求多核CPU)
- 并发：多个线程操作同一个资源
- 并发编程的本质：<font color="yellow">充分利用CPU资源</font>

## 2. 线程

### 1. 线程状态

- 新生：new
- 运行：runnable
- 阻塞：blocked
- 等待：watting
- 超时等待：time_watting
- 终止：terminated

### 2. waith和sleep的区别

- 来自不同的类：wait来自Object，sleep来自Thread
- 锁的释放不同：wait会释放锁，sleep不会释放锁
- 使用范围不同：wait只能在同步代码块中，sleep可以在任何地方使用
- 是否需要捕获异常：wait无需捕获异常，sleep需要捕获异常

### 3. Lock锁

- synchronized和Lock锁的区别：
  - synchronized是一个关键字，Lock是一个类
  - synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁
  - synchronized会自动释放锁，Lock必须手动释放锁，否则会导致死锁
  - synchronized会导致后续线程等待，Lock后续线程可以超时等待
  - synchronized为非公平锁、可重入的(线程已经获得某个锁，可以再次获取锁而不会出现死锁)，Lock可以设置为公平锁、可重入、可以判断锁
  - synchronized适合少量的代码同步问题，Lock适合大量的代码同步
- 公平锁和非公平锁：非公平锁允许插队，默认为非公平锁
- 可重用锁ReentrantLock

## 3. 生产者和消费者问题

### 1. synchronized解决方案

- wait和notify

  ```java
  this.wait();
  this.notifyAll();
  ```

- 使用while可以避免多个线程时虚假唤醒问题，但多个线程依然不能依次有序进行

### 2. JUC解决方案

- await和signal

  ```java
  condition.await();
  condition.signalAll();
  ```

- 可以精准通知和唤醒进程，以便让多个线程依次有序进行

## 4. 8锁现象(8个锁有关的问题)

1. 多个线程使用同一个对象，多个线程就是使用一把锁，先调用(先拿到锁)的先执行
2. 多个线程使用同一个对象，多个线程就是使用一把锁，先调用(先拿到锁)的先执行,即使在某方法中设置了阻塞
3. 多个线程，有的线程有锁，有的线程没锁，两者之间不存在竞争同一把锁的情况，先后执行顺序是随机的
4. 多个线程使用多把锁-随机执行
   - 被 synchronized 修饰的方法，锁的对象是方法的调用者
   - 调用者不同，它们之间用的不是同一个锁，相互之间没有关系。
5. Class锁：多个线程使用一个对象-顺序执行

   - 被 synchronized 和 static 同时修饰的方法，锁的对象是类的 class 对象，是唯一的一把锁，线程之间是顺序执行
   - 锁Class和锁对象的区别：
     - Class 锁 ，类模版，只有一个
     - 对象锁 ， 通过类模板可以new 多个对象
   - 如果全部都锁了Class，那么这个类下的所有对象都具有同一把锁
6. Class锁：多个线程使用多个对象-顺序执行
   - 被 synchronized 修饰 和 static 修饰的方法，锁的对象是类的 class 对象，是唯一的一把锁
   - Class锁是唯一的，所以多个对象使用的也是同一个Class锁
7. Class锁与对象锁：多个线程使用一个对象-随机执行
   - 被 synchronized和static修饰的方法，锁的对象是类的class对象，唯一的同一把锁
   - 只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰
8. Class锁与对象锁：多个线程使用多个对象-随机执行
   - 被 synchronized和static修饰的方法，锁的对象是类的class对象
   - 只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰

## 5. 安全集合类

### 1. List

- 可以更换Vector，Vector是安全的，但不推荐，Vector快被弃用了

- 推荐使用JUC工具类使其变得安全

  ```java
  List<String> list= Collections.synchronizedList(new ArrayList<>());
  ```

- 也可以使用CopyOnWriteArrayList

  ```java
  List<String> list= new CopyOnWriteArrayList<>();
  ```

- CopyOnWrite写入时复制(COP)，是计算机程序设计领域中的一种通用优化策略

  - 其核心思想是，如果有多个调用者（Callers）同时访问相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源
  - 直到某个调用者修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变，这过程对其他的调用者都是透明的（transparently）
  - 此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源
  - COP效率高

### 2. Set

- JUC工具类

  ```java
  Set<String> set = Collections.synchronizedSet(new HashSet<>());
  ```

- COP

  ```java
  Set<String> set = new CopyOnWriteArraySet<>();
  ```

- HashSet的底层为HashMap，HashSet的add的就是map的key(因为key要求不能重复所以HashSet不可重复，value则为一个常量)

### 3. Map

- 默认值：初始化容量，加载因子

  ```java
  Map<String,String> map=new HashMap<>();
  Map<String,String> map1=new HashMap<>(16,0.75);//两行代码等价
  ```
  一般工作中不会这样new HashMap

- JUC工具类

  ```java
  Map<String,String> map= Collections.synchronizedMap(new HashMap<>());
  ```

- 并发HashMap

  ```java
          Map<String,String> map= new ConcurrentHashMap<>();
  ```

## 6. Callable

### 1. Callable简介

- 可以有返回值，可以抛出异常
- 有缓存，效率高
- 可以使用futureTask.get()获取返回值，此方法可能会产生阻塞，记得放到最后或使用异步处理

## 7. 常用辅助类

### 1. CountDownLatch

- 减法计数器

  ```java
  CountDownLatch countDownLatch=new CountDownLatch(6);//计数器设置为6
  countDownLatch.countDown();//计数器减1
  
  countDownLatch.await();//等待计数器归零，在主线程里使用，会阻塞主线程
  ```

### 2. CyclicBarrier

- 加法计数器

  ```java
  CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
              System.out.println("执行成功");
          });//计数器设置为7，设置执行完毕后的线程
  cyclicBarrier.await();//等待达到计数器，在子线程里使用，会阻塞所有子线程
  ```

### 3. Semaphore

- 信号量，限制并发线程数量

  ```java
   Semaphore semaphore=new Semaphore(3);  //可用资源数3
          for (int i = 0; i < 6; i++) {
              new Thread(()->{
                  try {
                      semaphore.acquire();//获取资源，获取不到则阻塞
                      TimeUnit.SECONDS.sleep(3);
                  } catch (Exception e) {
                      e.printStackTrace();
                  }finally {
                      semaphore.release();//释放资源
                  }
              }).start();
          }
  ```

## 8. 读写锁

- 写锁(独占锁)和读锁(共享锁)

  ```java
  lock.writeLock().lock();   //写锁
  lock.writeLock().unlock();
  
  lock.readLock().lock();  //读锁
  lock.readLock().unlock();
  ```

  

## 9. 队列

### 1. 阻塞队列

- 写入：队列满了必须阻塞等待
- 读取：如果队列为空，必须阻塞等待生产
-  使用阻塞队列的情况：多线程并发和线程池

### 2. 四组API

|    方式    | 抛出异常 | 不抛异常，有返回值 | 阻塞等待 | 超时等待 |
| :--------: | :------: | :----------------: | :------: | :------: |
|    添加    |   add    |       offer        |   put    |  offer   |
|    移除    |  remove  |        poll        |   take   |   poll   |
| 判断队列首 | element  |        peek        |    -     |    -     |

### 3. 同步队列

- 阻塞队列的子类
- 容量为一，放入一个元素后，必须等待取出后才能再放一个元素
- 对应操作为put和take
- 












