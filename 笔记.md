# 1. 注解和反射

# 2. 多线程

## 1. 线程基础

 ### 1. 实现方式

1. 继承Thread类

   - 子类继承Thread类具备多线程能力

   - 启动线程：子类对象.start()

     ```java
       testThread1.start();
     ```

     

   - <font color="red">不建议使用：避免单继承局限性</font>

2. 实现Runnable接口

   - 实现接口Runnable具有多线程能力

   - 启动线程：传入目标对象+Thread对象.start()

     ```java
     new Thread(testThread3).start();
     ```

     

   - <font color="red">建议使用：灵活方便，同一个对象可以被多个线程使用</font>
   
3. 实现Callable接口（拓展）

   - 实现Callable接口，需要返回值类型
   - 重写call方法，需要抛出异常
   - 四个步骤：创建执行服务->提交执行->获取结果->关闭服务
   - 优点：可以定义返回值，可以抛出异常
   - 缺点：复杂



 ### 2. 静态代理

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实角色
- 优点：
  - 代理对象可以做很多真实对象做不了的事情
  - 真实对象专注自己的事情

 ### 3. Lambda表达式

- 函数式接口：如果一个接口只包含唯一一个抽象方法，那它就是一个函数式接口。对于函数式接口，我们可以用Lambda表达式来创建该接口的对象

  ```java
  love = a -> System.out.println("I love you-->" + a);
  ```
  

## 2. 线程状态

 ### 1. 线程的五个状态

1. 创建状态
2. 就绪状态
3. 阻塞状态
4. 运行状态
5. 死亡状态

 ### 2. 停止线程

- 不推荐使用stop()和destroy()方法（已弃用）
- 推荐让线程自己停下来，如设置一个标志位flag，当flag=false时，线程终止运行,或使用指定运行次数

 ### 3. 线程休眠

- sleep不会释放锁

 ### 4. 线程礼让

- 礼让线程：让当前正在执行的线程暂停，但不阻塞；即让线程从运行状态转化为就绪状态
- 礼让不一定成功，取决于CPU

 ### 5. Join

- Join合并线程，将此线程执行完毕后，再执行其他线程。该线程执行完毕前，其他线程阻塞，可以想象为插队

 ### 6. 线程优先级

- 线程调度按照优先级决定应该调度哪个线程来执行

- 优先级用数字表示，范围从1~10

  ```java
   //预定义常量
   Thread.MIN_PRIORITY = 1;
   Thread.MAX_PRIORITY = 10;
   Thread.NORM_PRIORITY = 5;
  ```

- 可以用getPriority()和setPriority()来获取和改变线程优先级

- 优先级只是参考，实际执行效果还是取决于CPU

 ### 7. 守护线程

- 线程分为用户进程和守护进程

- JVM必须确保用户进程执行完毕，而不用等待守护线程执行完毕

- 守护线程的例子：后台记录操作日志，监控内存，垃圾回收等

- 设置方法

  ```java
  thread.setDaemon(true);//默认为false表示用户线程
  ```

## 3. 线程同步

 ### 1. 并发

- 同一个对象被多个线程同时操作

### 2. 线程同步

- 处理多线程问题时，多个线程访问同一个对象，需要线程同步机制

- 线程同步其实是一种等待机制，多个需要同时访问此对象的线程进入这个<font color="red">对象的等待池</font>形成队列，等待前面的线程使用完毕，下个线程再使用

- 线程同步还需要锁：为保证数据在方法中被访问时的正确性，在访问时加入<font color="red">锁机制synchronized</font>，当一个线程获得对象的排他锁、独占资源时，其他线程必须等待，使用后释放锁即可

- 锁机制可能会导致以下问题
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起
  - 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置

### 3. 同步方法

  - synchronized方法控制对象的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行

    ```java
    public synchronized void method(){}
    ```

  - 缺点：synchronized方法会影响其效率

  - synchronized锁的对象为变化的量，依据实际问题会用到同步方法和同步块

### 4. 同步块

  - Obj称之为同步监视器

    - Obj可以是任何对象，推荐用共享资源作为同步监视器
    - 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是本身或Class

    ```java
    synchronized(Obj){}
    ```

  - 同步监视器执行过程

    1. 第一个线程访问，锁定同步监视器，执行其中的代码
    2. 第二个线程访问，发现同步监视器被锁定，无法访问
    3. 第一个线程访问完毕，解锁同步监视器
    4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问
    
  - JUC包里的线程安全类型

### 5. 死锁

  - 产生死锁的四个必要条件
    - 互斥
    - 请求与等待
    - 不可剥夺
    - 循环等待
  - 只需破坏四个条件中的一个或多个即可避免死锁

### 6. 锁

  - 通过显示定义同步锁对象来实现同步。同步锁使用Lock对象充当
  - java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问资源之前先获得Lock对象
  - ReentranLock(可重入锁)类实现了Lock，它拥有与synchroized相同的并发性和内存语义，在线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁
  - synchronized与Lock对比
    - Lock是显示锁（手动开启和关闭锁，**切记要关闭锁**），synchronized是隐式锁，出了作用域自动释放
    - Lock只有代码块锁，synchronized有代码块锁和方法锁
    - 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）
    - 优先使用顺序：Lock>同步代码块（已经进入方法体，分配了相应资源）>同步方法（在方法体之外）

## 4. 线程协作与通信

### 1. 生产者消费者模式

- 生产者和消费者共享同一个资源，并且生产者和消费者直接相互依赖，互为条件
- 在生产者消费者问题中，仅有synchronized是不够的
  - synchronized可阻止并发更新同一个共享资源，实现了同步
  - synchronized不能用来实现不同线程之间的消息传递（通信）
- 解决方法：
  - 建立一个缓冲区，生产者将产品放入，消费者将产品取出（管程法）
  - 设置一个标志位，true生产，false等待（信号灯法）

### 2. 线程通信问题的方法

- Java提供了几个方法解决线程直接的通信问题

  | 方法名 | 作用 |
  | :----: | :----: |
  |  wait()| 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 |
  | wait(long timeout) | 指定等待的毫秒数 |
  | notify() | 唤醒一个处于等待状态的线程 |
  | notifyAll() | 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 |
  
- 注意：以上均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException

## 5. 线程池

### 1. 线程池

- 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大
- 思路：提起创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁线程，实现重复利用，类似生活中的公共交通工具
- 好处：
  - 提供相应速度
  - 降低资源消耗
  - 便于线程管理

### 2. 使用线程池

- 线程池核心参数
  - corePoolSize：核心池的大小
  - maximumPoolSize：最大线程数
  - keepAliveTime：线程没有任务时最长保持多长时间后会终止
- 相关API：ExecutorService和Executors
  - ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
  - Exrcutors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池

# 3. 网络编程

## 1. 计算机网络概述

- ip，端口号：TCP和UDP使用两套不同的端口号，都是0~65535

  ```bash
  netstat -ano  #查看所有端口
  netstat -ano | findstr 8080  #查找指定端口
  tasklist | findstr 8696  #查看指定PID的进程
  ```

- 协议

## 2. TCP实现聊天

### 1. 客户端

1. 连接服务器Socket
2. 发送消息

### 2. 服务端

1. 建立服务的端口ServiceSocket
2. 等待用户连接accept()（阻塞式监听）
3. 接收用户消息



## 3. TCP实现文件上传

## 4. UDP

- UDP并没有严格的客户端服务端区分

## 5. URL

- 协议://ip:端口/项目名/资源









