# 1. 注解和反射

# 2. 多线程

## 1. 线程基础

 ### 1. 实现方式

1. 继承Thread类

   - 子类继承Thread类具备多线程能力

   - 启动线程：子类对象.start()

     ```java
       testThread1.start();
     ```

     

   - <font color="red">不建议使用：避免单继承局限性</font>

2. 实现Runnable接口

   - 实现接口Runnable具有多线程能力

   - 启动线程：传入目标对象+Thread对象.start()

     ```java
     new Thread(testThread3).start();
     ```

     

   - <font color="red">建议使用：灵活方便，同一个对象可以被多个线程使用</font>
   
3. 实现Callable接口（拓展）

   - 实现Callable接口，需要返回值类型
   - 重写call方法，需要抛出异常
   - 四个步骤：创建执行服务->提交执行->获取结果->关闭服务
   - 优点：可以定义返回值，可以抛出异常
   - 缺点：复杂



 ### 2. 静态代理

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实角色
- 优点：
  - 代理对象可以做很多真实对象做不了的事情
  - 真实对象专注自己的事情

 ### 3. Lambda表达式

- 函数式接口：如果一个接口只包含唯一一个抽象方法，那它就是一个函数式接口。对于函数式接口，我们可以用Lambda表达式来创建该接口的对象

  ```java
  love = a -> System.out.println("I love you-->" + a);
  ```
  

## 2. 线程状态

 ### 1. 线程的五个状态

1. 创建状态
2. 就绪状态
3. 阻塞状态
4. 运行状态
5. 死亡状态

 ### 2. 停止线程

- 不推荐使用stop()和destroy()方法（已弃用）
- 推荐让线程自己停下来，如设置一个标志位flag，当flag=false时，线程终止运行,或使用指定运行次数

 ### 3. 线程休眠

- sleep不会释放锁

 ### 4. 线程礼让

- 礼让线程：让当前正在执行的线程暂停，但不阻塞；即让线程从运行状态转化为就绪状态
- 礼让不一定成功，取决于CPU

 ### 5. Join

- Join合并线程，将此线程执行完毕后，再执行其他线程。该线程执行完毕前，其他线程阻塞，可以想象为插队

 ### 6. 线程优先级

- 线程调度按照优先级决定应该调度哪个线程来执行

- 优先级用数字表示，范围从1~10

  ```java
   //预定义常量
   Thread.MIN_PRIORITY = 1;
   Thread.MAX_PRIORITY = 10;
   Thread.NORM_PRIORITY = 5;
  ```

- 可以用getPriority()和setPriority()来获取和改变线程优先级

- 优先级只是参考，实际执行效果还是取决于CPU

 ### 7. 守护线程

- 线程分为用户进程和守护进程

- JVM必须确保用户进程执行完毕，而不用等待守护线程执行完毕

- 守护线程的例子：后台记录操作日志，监控内存，垃圾回收等

- 设置方法

  ```java
  thread.setDaemon(true);//默认为false表示用户线程
  ```

## 3. 线程同步

 ### 1. 并发

- 同一个对象被多个线程同时操作

### 2. 线程同步

- 处理多线程问题时，多个线程访问同一个对象，需要线程同步机制
- 线程同步其实是一种等待机制，多个需要同时访问此对象的线程进入这个<font color="red">对象的等待池</font>形成队列，等待前面的线程使用完毕，下个线程再使用
- 线程同步还需要锁：为保证数据在方法中被访问时的正确性，在访问时加入<font color="red">锁机制synchronized</font>，当一个线程获得对象的排他锁、独占资源时，其他线程必须等待，使用后释放锁即可
- 锁机制可能会导致以下问题
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起
  - 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置

