# 1. 注解和反射

## 1. 注解

## 2. 反射

# 2. 多线程

## 1. 线程基础

 ### 1. 实现方式

1. 继承Thread类

   - 子类继承Thread类具备多线程能力

   - 启动线程：子类对象.start()

     ```java
       testThread1.start();
     ```

   - <font color="red">不建议使用：避免单继承局限性</font>

2. 实现Runnable接口

   - 实现接口Runnable具有多线程能力

   - 启动线程：传入目标对象+Thread对象.start()

     ```java
     new Thread(testThread3).start();
     ```

   - 前期建议使用：灵活方便，同一个对象可以被多个线程使用

3. 实现Callable接口（拓展）

   - 实现Callable接口，需要返回值类型
   - 重写call方法，需要抛出异常
   - 四个步骤：创建执行服务->提交执行->获取结果->关闭服务
   - 优点：可以定义返回值，可以抛出异常
   - 缺点：复杂
   - 后期主要使用该方法



 ### 2. 静态代理

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实角色
- 优点：
  - 代理对象可以做很多真实对象做不了的事情
  - 真实对象专注自己的事情

 ### 3. Lambda表达式

- 函数式接口：如果一个接口只包含唯一一个抽象方法，那它就是一个函数式接口。对于函数式接口，我们可以用Lambda表达式来创建该接口的对象

  ```java
  love = a -> System.out.println("I love you-->" + a);
  ```
  

## 2. 线程状态

 ### 1. 线程的五个状态

1. 创建状态
2. 就绪状态
3. 阻塞状态
4. 运行状态
5. 死亡状态

 ### 2. 停止线程

- 不推荐使用stop()和destroy()方法（已弃用）
- 推荐让线程自己停下来，如设置一个标志位flag，当flag=false时，线程终止运行,或使用指定运行次数

 ### 3. 线程休眠

- sleep不会释放锁

 ### 4. 线程礼让

- 礼让线程：让当前正在执行的线程暂停，但不阻塞；即让线程从运行状态转化为就绪状态
- 礼让不一定成功，取决于CPU

 ### 5. Join

- Join合并线程，将此线程执行完毕后，再执行其他线程。该线程执行完毕前，其他线程阻塞，可以想象为插队

 ### 6. 线程优先级

- 线程调度按照优先级决定应该调度哪个线程来执行

- 优先级用数字表示，范围从1~10

  ```java
   //预定义常量
   Thread.MIN_PRIORITY = 1;
   Thread.MAX_PRIORITY = 10;
   Thread.NORM_PRIORITY = 5;
  ```

- 可以用getPriority()和setPriority()来获取和改变线程优先级

- 优先级只是参考，实际执行效果还是取决于CPU

 ### 7. 守护线程

- 线程分为用户进程和守护进程

- JVM必须确保用户进程执行完毕，而不用等待守护线程执行完毕

- 守护线程的例子：后台记录操作日志，监控内存，垃圾回收等

- 设置方法

  ```java
  thread.setDaemon(true);//默认为false表示用户线程
  ```

## 3. 线程同步

 ### 1. 并发

- 同一个对象被多个线程同时操作

### 2. 线程同步

- 处理多线程问题时，多个线程访问同一个对象，需要线程同步机制

- 线程同步其实是一种等待机制，多个需要同时访问此对象的线程进入这个<font color="red">对象的等待池</font>形成队列，等待前面的线程使用完毕，下个线程再使用

- 线程同步还需要锁：为保证数据在方法中被访问时的正确性，在访问时加入<font color="red">锁机制synchronized</font>，当一个线程获得对象的排他锁、独占资源时，其他线程必须等待，使用后释放锁即可

- 锁机制可能会导致以下问题
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起
  - 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置

### 3. 同步方法

  - synchronized方法控制对象的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行

    ```java
    public synchronized void method(){}
    ```

  - 缺点：synchronized方法会影响其效率

  - synchronized锁的对象为变化的量，依据实际问题会用到同步方法和同步块

### 4. 同步块

  - Obj称之为同步监视器

    - Obj可以是任何对象，推荐用共享资源作为同步监视器
    - 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是本身或Class

    ```java
    synchronized(Obj){}
    ```

  - 同步监视器执行过程

    1. 第一个线程访问，锁定同步监视器，执行其中的代码
    2. 第二个线程访问，发现同步监视器被锁定，无法访问
    3. 第一个线程访问完毕，解锁同步监视器
    4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问
    
  - JUC包里的线程安全类型

### 5. 死锁

  - 产生死锁的四个必要条件
    - 互斥
    - 请求与等待
    - 不可剥夺
    - 循环等待
  - 只需破坏四个条件中的一个或多个即可避免死锁

### 6. 锁

  - 通过显示定义同步锁对象来实现同步。同步锁使用Lock对象充当
  - java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问资源之前先获得Lock对象
  - ReentranLock(可重入锁)类实现了Lock，它拥有与synchroized相同的并发性和内存语义，在线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁
  - synchronized与Lock对比
    - Lock是显示锁（手动开启和关闭锁，**切记要关闭锁**），synchronized是隐式锁，出了作用域自动释放
    - Lock只有代码块锁，synchronized有代码块锁和方法锁
    - 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）
    - 优先使用顺序：Lock>同步代码块（已经进入方法体，分配了相应资源）>同步方法（在方法体之外）

## 4. 线程协作与通信

### 1. 生产者消费者模式

- 生产者和消费者共享同一个资源，并且生产者和消费者直接相互依赖，互为条件
- 在生产者消费者问题中，仅有synchronized是不够的
  - synchronized可阻止并发更新同一个共享资源，实现了同步
  - synchronized不能用来实现不同线程之间的消息传递（通信）
- 解决方法：
  - 建立一个缓冲区，生产者将产品放入，消费者将产品取出（管程法）
  - 设置一个标志位，true生产，false等待（信号灯法）

### 2. 线程通信问题的方法

- Java提供了几个方法解决线程直接的通信问题

  | 方法名 | 作用 |
  | :----: | :----: |
  |  wait()| 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 |
  | wait(long timeout) | 指定等待的毫秒数 |
  | notify() | 唤醒一个处于等待状态的线程 |
  | notifyAll() | 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 |
  
- 注意：以上均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException

## 5. 线程池

### 1. 线程池

- 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大
- 思路：提起创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁线程，实现重复利用，类似生活中的公共交通工具
- 好处：
  - 提供相应速度
  - 降低资源消耗
  - 便于线程管理

### 2. 使用线程池

- 线程池核心参数
  - corePoolSize：核心池的大小
  - maximumPoolSize：最大线程数
  - keepAliveTime：线程没有任务时最长保持多长时间后会终止
- 相关API：ExecutorService和Executors
  - ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
  - Exrcutors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池

# 3. 网络编程

## 1. 计算机网络概述

- ip，端口号：TCP和UDP使用两套不同的端口号，都是0~65535

  ```bash
  netstat -ano  #查看所有端口
  netstat -ano | findstr 8080  #查找指定端口
  tasklist | findstr 8696  #查看指定PID的进程
  ```

- 协议

## 2. TCP实现聊天

### 1. 客户端

1. 连接服务器Socket
2. 发送消息

### 2. 服务端

1. 建立服务的端口ServiceSocket
2. 等待用户连接accept()（阻塞式监听）
3. 接收用户消息

## 3. TCP实现文件上传

## 4. UDP

- UDP并没有严格的客户端服务端区分

## 5. URL

- 协议://ip:端口/项目名/资源

# 4.IO流

## 1. 文件

### 1. 文件

- 保存的数据

### 2. 文件流

- 文件再程序中是以流的形式来操作的

- 输入流：数据从数据源(文件)到程序(内存)的路径

  输出流：数据从程序(内存)到数据源(文件)的路径

## 2. IO流

### 1. IO流原理

- Java程序中，对于数据的输入/输出操作以流(stream)的方式进行
- Java.io包中提供了各种流的类和接口，用以获取不同种类的数据，并通过方法输入或输出数据

### 2. 流的分类

- 字节流：按8bit(一字节)为单位

  字符流：按字符为单位

- Java的IO流都是由一下4个抽象基类产生

  | 抽象基类 | 字节流 | 字符流 |
  | :----: | :----: |:----:|
  | 输入流 | InputStream | Reader |
  | 输出流 | OutputStream | Writer |

- 字符流是字符操作的，只能用于文本文件，其他文件可能会造成文件损坏

  使用字节流操作文本文件则可能造成乱码(拷贝时不会)

- 节点流：从一个特定的数据源读写数据，如FileReader、FileWriter

  处理流：也叫包装流，是连接已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter

- 处理流的优点：

  - 提高性能：可以增加缓冲来提供输入输出的效率
  - 操作便捷：提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便

### 3. 常见流

- 对象处理流：

  - 序列化和反序列化

  - 某个对象支持序列化机制，必须让其类是可序列化的，即该类必需实现Serialized(推荐使用，标记接口，内部无方法)或Externalizable两个接口中的任一个

  - 使用ObjectOutputStream、ObjectInputStream进行序列化、反序列化

  - static和transient修饰的成员默认不会被序列化，其他属性也可以通过transient关键字使其不被序列化

  - 序列化具备可继承性，即子类默认也会实现序列化

  - 可以添加serialVersionUID(序列化版本号)提供兼容性，添加后会被认为是版本修改而不是全新的类

    ```java
    private static final long serialVersionUID = 1L;
    ```

  - 反序列化时需要向下转型，反序列化时的类需要有访问权限

  - 反序列化的顺序要和序列化时一致

- 标准输入输出流

  |  | 编译类型 | 运行类型 | 默认设备 |
  | :--: | :----: | :----: | :----: |
  | System.in | InputStream | BufferedInputStream | 键盘 |
  | System.out | PrintStream | PrintStream | 显示器 |

- 转换流

  - InputStreamReader和OutputStreamWriter
  - 把字节流转换为字符流
  - 字符流不能指定编码，通过这种方式可以得到指定编码的字符流

- 打印流

  - PrintStream和PrintWriter
  - 打印流只有输出流没有输入流
  - PrintStream使用的是write()方法，默认情况下输出位置为标准输出
  - System.out.println();中的out就是System类中的一个PrintStream常量

## 3. Properties类

### 1. Properties配置文件

- 配置文件格式

  键=值

  键=值

- 键值对不需要有空格，值不需要使用引号，值的默认类型为String

### 2. Properties类常见方法

- load：加载配置文件键值对到Properties对象
- list：将数据显示到指定设备
- getProperties(key)：根据键获取值
- setProperties(key,value)：设置键值对到Properties对象
- store：将Properties对象存储到配置文件，使用字节流时有中文会保存为Unicode码

# 5. JVM基础

## 1. JVM探究

### 1. 常见面试题

- Java8虚拟机和之前的变化
- OOM，StackOverFlow
- JVM的常用调优参数
- 内存快照和Dump文件
- 类加载器

### 2. 常见概念

- JVM的位置、JVM的体系结构
- 类加载器
- 双亲委派机制、沙箱安全机制
- Native
- PC寄存器
- 方法区、栈(存地址)、堆(存地址对应的属性和值)
- 三种JVM
- 新生区、老年区、永久区
- 堆内存调优
- GC(垃圾回收)
- JMM(Java内存模型)

## 2. JVM的体系结构

- JVM的位置：JVM介于操作系统和Java程序之间
- JVM是用C写的
- 体系结构图 <img src="https://i.bmp.ovh/imgs/2022/01/cc59183ebe020510.png"  />
- 栈和PC都不会有垃圾，JVM调优在堆里调（方法区是特殊的堆）

## 3. JVM的组件

### 1. 类加载器

- 作用：加载Class文件

- 步骤

  ![](https://s3.bmp.ovh/imgs/2022/01/6a4f76a564b524ca.png)

- 类加载器的分级

  - JVM的类加载器
  - 启动类(根)加载器
  - 扩展类加载器
  - 应用程序(系统类)加载器


### 2. 双亲委派机制

- 运行类时会先从下往上找类加载器中的类，如果多个加载器中都有类，最后会执行的类是上级加载器中的类
- 作用：保证安全
- 步骤：
  1. 类加载器收到类加载的请求
  2. 将这个请求向上委托给父类加载器完成
  3. 启动加载器检查是否能够加载当前类，能加载就结束，否则抛出异常通知子加载器进行加载
  4. 子类加载器重复步骤3

### 3. 沙箱安全机制

- 将Java代码限定在JVM虚拟机特定的运行范围中，并且严格限制代码对本地系统资源的访问
- 沙箱的基本组件：
  - 字节码校验器：确保Java类文件遵顼Java语言规范，可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类
  - 类加载器：防止恶意代码区干涉善意代码；守护被信任的类库边界；将代码归入保护域，确定了代码可以进行哪些操作
  - 存储控制器：控制核心API对操作系统的存取权限，可以由用户指定控制策略
  - 安全管理器：核心API和操作系统间的主要接口，实现权限控制，比存储控制器优先级高
  - 安全软件包：java.security下的类及其扩展包下的类，允许用户为自己的应用增加新的安全特性，包括安全提供者、消息摘要、数字签名(KeyTools)、加密、鉴别等

### 4. Native

- native关键字表明超出了Java的作用范围，需要调用C语言库，会进入本地方法栈，调用本地方法接口JNI。以便融合不同编程语言，为Java使用
- Java诞生时C/C++横行，想要立足，必须能调用C/C++的程序，于是便专门在内存中开辟一块标记区域：Native Method Strack来登记Native方法
- 最终执行时，加载本地方法库中的方法需通过JNI

### 5. 程序计数器PC

- 每一个线程都有一个PC，是线程私有的，本质是一个指针，指向方法区的字节码
- 用来存储指向下一条指令的地址，也就是即将要执行的指令代码，以便执行引擎读取下一条指令
- 是一个非常小的内存地址，几乎可以不计

### 6. 方法区

- 方法区被所有线程共享，此区域属于共享区间
- 所有字段、方法字节码、接口以及一些特殊方法（如构造函数）也再次定义。简单说，所有定义的方法的信息都保存在该区域
- 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池也存放在方法区中，<font color="yellow">但实例变量存在堆内存中，和方法区无关</font>

### 7. 栈

- 栈内存，主管程序运行，生命周期和线程同步
- 线程结束，栈内存释放。对于栈来说，不存在垃圾回收
- 栈的内容：8大类型、对象引用、实例方法
- 栈运行原理：栈帧，一个方法产生一个栈帧，执行最上面的方法

### 8. 堆

- 一个JVM只有一个堆内存
- 堆内存的大小是可以调节的
- 类加载器读取类文件后，会把变量放在堆区
- 堆分为三个区域：
  - 新生区：又分为伊甸园区(类诞生和成长甚至死亡的地方，所有的对象都在这里new出来)和幸存者区(一般有两个，以0、1标识，0就是from、1是to，活过垃圾回收的会进入这里)
  - 养老区
  - 永久区(JDK8以后叫元空间)：常驻内存，用来存放JDK自身的Class对象、Interface元数据，存储的是Java运行时的一些环境或类信息。不存在垃圾回收，关闭虚拟机就会释放内存。使用的是物理机的内存，不是JVM的内存
- GC主要是在新生区和养老区
- 堆内存满了会报OOM，可以使用MAT和Jprofiler等分析Dump文件，快速定位内存泄漏

### 9. 三种JVM

- Sun HotSpot
- BEA JRockit
- IBM J9VM

### 10. GC及其常用算法

- GC两种类型：轻GC和重GC(全局GC)

- 常用算法：

  - 标记清除法

    ![](https://s3.bmp.ovh/imgs/2022/01/e9d6f1f54014ae16.png)

  - 标记压缩法

    ![](https://s3.bmp.ovh/imgs/2022/01/76a2b5d5c182905d.png)

  - 复制算法

    将存活的对象复制到to区，然后清空from区(谁是空的谁是to区，谁不是空的谁是from区)

  - 分代收集法

    分为新生代和老年代，新生代用复制算法，老年代用标记压缩法

  - 总结：

    - 内存使用次数：复制算法(一次)<标记清除法(两次)<标记压缩法(多次)
    - 内存整齐度：复制算法=标记压缩法>标记清除法
    - 内存利用率：标记压缩法=标记清除法>复制算法

# 6. JUC并发

## 1. JUC简介

### 1. 什么是JUC

- JUC是java.util .concurrent工具包的简称，这是一个处理线程的工具包

### 2. 回顾多线程

- Runnable：没有返回值，效率相对Callable较低
- 线程和进程：Java默认有两个进程(main和GC)

### 3. 并发和并行

- 并行：多个进程干同样的事(要求多核CPU)
- 并发：多个线程操作同一个资源
- 并发编程的本质：<font color="yellow">充分利用CPU资源</font>

## 2. 线程

### 1. 线程状态

- 新生：new
- 运行：runnable
- 阻塞：blocked
- 等待：watting
- 超时等待：time_watting
- 终止：terminated

### 2. waith和sleep的区别

- 来自不同的类：wait来自Object，sleep来自Thread
- 锁的释放不同：wait会释放锁，sleep不会释放锁
- 使用范围不同：wait只能在同步代码块中，sleep可以在任何地方使用
- 是否需要捕获异常：wait无需捕获异常，sleep需要捕获异常

### 3. Lock锁

- synchronized和Lock锁的区别：
  - synchronized是一个关键字，Lock是一个类
  - synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁
  - synchronized会自动释放锁，Lock必须手动释放锁，否则会导致死锁
  - synchronized会导致后续线程等待，Lock后续线程可以超时等待
  - synchronized为非公平锁、可重入的(线程已经获得某个锁，可以再次获取锁而不会出现死锁)，Lock可以设置为公平锁、可重入、可以判断锁
  - synchronized适合少量的代码同步问题，Lock适合大量的代码同步
- 公平锁和非公平锁：非公平锁允许插队，默认为非公平锁
- 可重用锁ReentrantLock

## 3. 生产者和消费者问题

### 1. synchronized解决方案

- wait和notify

  ```java
  this.wait();
  this.notifyAll();
  ```

- 使用while可以避免多个线程时虚假唤醒问题，但多个线程依然不能依次有序进行

### 2. JUC解决方案

- await和signal

  ```java
  condition.await();
  condition.signalAll();
  ```

- 可以精准通知和唤醒进程，以便让多个线程依次有序进行

## 4. 8锁现象(8个锁有关的问题)

1. 多个线程使用同一个对象，多个线程就是使用一把锁，先调用(先拿到锁)的先执行
2. 多个线程使用同一个对象，多个线程就是使用一把锁，先调用(先拿到锁)的先执行,即使在某方法中设置了阻塞
3. 多个线程，有的线程有锁，有的线程没锁，两者之间不存在竞争同一把锁的情况，先后执行顺序是随机的
4. 多个线程使用多把锁-随机执行
   - 被 synchronized 修饰的方法，锁的对象是方法的调用者
   - 调用者不同，它们之间用的不是同一个锁，相互之间没有关系。
5. Class锁：多个线程使用一个对象-顺序执行

   - 被 synchronized 和 static 同时修饰的方法，锁的对象是类的 class 对象，是唯一的一把锁，线程之间是顺序执行
   - 锁Class和锁对象的区别：
     - Class 锁 ，类模版，只有一个
     - 对象锁 ， 通过类模板可以new 多个对象
   - 如果全部都锁了Class，那么这个类下的所有对象都具有同一把锁
6. Class锁：多个线程使用多个对象-顺序执行
   - 被 synchronized 修饰 和 static 修饰的方法，锁的对象是类的 class 对象，是唯一的一把锁
   - Class锁是唯一的，所以多个对象使用的也是同一个Class锁
7. Class锁与对象锁：多个线程使用一个对象-随机执行
   - 被 synchronized和static修饰的方法，锁的对象是类的class对象，唯一的同一把锁
   - 只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰
8. Class锁与对象锁：多个线程使用多个对象-随机执行
   - 被 synchronized和static修饰的方法，锁的对象是类的class对象
   - 只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰

## 5. 安全集合类

### 1. List

- 可以更换Vector，Vector是安全的，但不推荐，Vector快被弃用了

- 推荐使用JUC工具类使其变得安全

  ```java
  List<String> list= Collections.synchronizedList(new ArrayList<>());
  ```

- 也可以使用CopyOnWriteArrayList

  ```java
  List<String> list= new CopyOnWriteArrayList<>();
  ```

- CopyOnWrite写入时复制(COP)，是计算机程序设计领域中的一种通用优化策略

  - 其核心思想是，如果有多个调用者（Callers）同时访问相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源
  - 直到某个调用者修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变，这过程对其他的调用者都是透明的（transparently）
  - 此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源
  - COP效率高

### 2. Set

- JUC工具类

  ```java
  Set<String> set = Collections.synchronizedSet(new HashSet<>());
  ```

- COP

  ```java
  Set<String> set = new CopyOnWriteArraySet<>();
  ```

- HashSet的底层为HashMap，HashSet的add的就是map的key(因为key要求不能重复所以HashSet不可重复，value则为一个常量)

### 3. Map

- 默认值：初始化容量，加载因子

  ```java
  Map<String,String> map=new HashMap<>();
  Map<String,String> map1=new HashMap<>(16,0.75);//两行代码等价
  ```
  一般工作中不会这样new HashMap

- JUC工具类

  ```java
  Map<String,String> map= Collections.synchronizedMap(new HashMap<>());
  ```

- 并发HashMap

  ```java
          Map<String,String> map= new ConcurrentHashMap<>();
  ```

## 6. Callable

### 1. Callable简介

- 可以有返回值，可以抛出异常
- 有缓存，效率高
- 可以使用futureTask.get()获取返回值，此方法可能会产生阻塞，记得放到最后或使用异步处理

## 7. 常用辅助类

### 1. CountDownLatch

- 减法计数器

  ```java
  CountDownLatch countDownLatch=new CountDownLatch(6);//计数器设置为6
  countDownLatch.countDown();//计数器减1
  
  countDownLatch.await();//等待计数器归零，在主线程里使用，会阻塞主线程
  ```

### 2. CyclicBarrier

- 加法计数器

  ```java
  CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
              System.out.println("执行成功");
          });//计数器设置为7，设置执行完毕后的线程
  cyclicBarrier.await();//等待达到计数器，在子线程里使用，会阻塞所有子线程
  ```

### 3. Semaphore

- 信号量，限制并发线程数量

  ```java
   Semaphore semaphore=new Semaphore(3);  //可用资源数3
          for (int i = 0; i < 6; i++) {
              new Thread(()->{
                  try {
                      semaphore.acquire();//获取资源，获取不到则阻塞
                      TimeUnit.SECONDS.sleep(3);
                  } catch (Exception e) {
                      e.printStackTrace();
                  }finally {
                      semaphore.release();//释放资源
                  }
              }).start();
          }
  ```

## 8. 读写锁

- 写锁(独占锁)和读锁(共享锁)

  ```java
  lock.writeLock().lock();   //写锁
  lock.writeLock().unlock();
  
  lock.readLock().lock();  //读锁
  lock.readLock().unlock();
  ```

  

## 9. 队列

### 1. 阻塞队列

- 写入：队列满了必须阻塞等待
- 读取：如果队列为空，必须阻塞等待生产
-  使用阻塞队列的情况：多线程并发和线程池

### 2. 四组API

|    方式    | 抛出异常 | 不抛异常，有返回值 | 阻塞等待 | 超时等待 |
| :--------: | :------: | :----------------: | :------: | :------: |
|    添加    |   add    |       offer        |   put    |  offer   |
|    移除    |  remove  |        poll        |   take   |   poll   |
| 判断队列首 | element  |        peek        |    -     |    -     |

### 3. 同步队列

- 阻塞队列的子类
- 容量为一，放入一个元素后，必须等待取出后才能再放一个元素
- 对应操作为put和take

## 10. 线程池

### 1. 池化技术

- 创建和销毁会销毁大量资源
- 线程池，连接池，内存池，对象池，字符常量池

### 2. 线程池

- 线程复用，最大并发控制，线程管理
- 好处：降低资源消耗、提供响应速度、方便管理

### 3. Executors工具类

- 3大方法

  ```java
  Executors.newSingleThreadExecutor();//单个线程线程池
  Executors.newFixedThreadPool(6);//固定大小线程池
  Executors.newCachedThreadPool();//大小可变线程池
  ```

- 7大参数

  ```java
  public ThreadPoolExecutor(int corePoolSize,  //核心(最小)线程池大小
                                int maximumPoolSize,  //最大核心线程大小
                                long keepAliveTime,  //无人调用就释放的超时时间
                                TimeUnit unit,  //超时时间单位
                                BlockingQueue<Runnable> workQueue,  //阻塞队列
                                ThreadFactory threadFactory,  //线程工厂，用于创建线程
                                RejectedExecutionHandler handler){}  //拒绝策略
  ```
  工作中常用自定义线程

- 4种拒绝策略

  - DiscardPolicy：拒绝执行，不抛出异常
  - CallerRunsPolicy：交给父线程处理
  - AbortPolicy：拒绝执行，抛出异常
  - DiscardOldestPolicy：尝试和最早的竞争，成功则执行，失败则拒绝执行，也不会抛出异常

### 4. 最大线程数策略

- CPU密集型：CPU是几核就是几
- IO密集型：判断程序中IO消耗大的线程数，大于它即可

## 11. 四种函数式接口

### 1. 函数式接口

- 只有一个方法的接口
- 简化编程，框架底层大量使用
- lambda表达式，链式编程，函数式接口，Stream流式计算

### 2. Function

- 函数型接口，输入参数和返回值均有

- 输出为HelloHello

  ```java
  Function<String,String> function=s -> s+s;  //最简形态
  Function<String,String> function=(s) -> {return s+s;};  //一般形态
  Function<String,String> function=new Function<String, String>() {
              @Override
              public String apply(String s) {
                  return s+s;
              }
          };  //最初形态
  System.out.println(function.apply("Hello"));
  ```

### 3. Predicate

- 断定型接口，有一个输入参数，返回值只能为Boolean

- 输出为false

  ```java
  Predicate<String> predicate=s->s.isEmpty();  
  Predicate<String> predicate= String::isEmpty;  //方法引用
  System.out.println(predicate.test("aaa"));
  ```

### 4. Consumer

- 消费型接口，只有输入参数，没有返回值

- 输出为hello

  ```java
  Consumer<String> consumer= x -> System.out.println(x);
  consumer.accept("hello");
  ```

### 5. Supplier

- 供给型接口，没有输入参数，只有返回值

- 输出为HelloWorld

  ```java
  Supplier<String> supplier=() ->"HelloWorld";
  System.out.println(supplier.get());
  ```

## 12. Stream流式计算

### 1. Stream流式计算概念

- 集合(或数据库)只用来存储，计算交给流

### 2. 实例

```java
        User u1=new User(1,"a",21);   //id,name,age
        User u2=new User(2,"b",22);
        User u3=new User(3,"c",23);
        User u4=new User(4,"d",24);
        User u5=new User(6,"e",25);
        List<User> list = Arrays.asList(u1, u2, u3, u4, u5);

        Stream<User> stream = list.stream();
        stream.filter(user -> user.getId()%2==0)  //筛选id为偶数
                .filter(user -> user.getAge()>23)  //筛选age大于23
                .map(user -> user.getName().toUpperCase())  //name转换为大写
                .sorted((uu1,uu2)->{ return  uu2.compareTo(uu1);})  //倒序排序
                .limit(1)   //限制输出为一个
                .forEach(System.out::println);   //forEach遍历
```

## 13. Fork/Join

### 1. Fork/Join概念

- 将一个线程拆开，并行执行任务，提高效率
- 特点：工作窃取(将其他拆分线程未完成的任务窃取来执行)
- 大数据量才能更优

## 14. 异步回调

### 1. Future

- 设计初衷：对将来的某个事件的结果进行建模

## 15.JMM(Java内存模型)

### 1. JMM

- 一个概念及其约定，并无对应实体

- 把内存分为工作内存和主存

- 关于JMM的一些同步的约定：

  - 线程解锁前，必须**立即**把共享变量刷回主存
  - 线程加锁前，必须读取主存中的最新值读到工作内存中
  - 加锁和解锁是同一把锁

- 8种操作

  <img src="https://s3.bmp.ovh/imgs/2022/01/cd3774260984aaf8.png" style="zoom: 80%;" />

  - lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态
  - read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用
  - load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；
  - use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作
  - assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作
  - store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用
  - write(写入)：作用于主内存，它把store传送值放到主内存中的变量中
  - unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定
  - **注意：以上8种操作必须成对出现**(如出现read一定要有write)

### 2. volatile

- 适用于变量，解决线程不知道主存中的值已经被修改过了的问题
- volatile是Java虚拟机提供的轻量级的同步机制
- 特性：
  - 保证可见性：可见性指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
  - <font color='red'>不保证原子性</font>：原子性指一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<u>可以使用原子类保证原子性</u>
  - 禁止指令重排：即**有序性**，程序执行的顺序按照代码的先后顺序执行

### 3. 单例模式

- 饿汉模式：立即加载，无论是否会用到这个对象，都会加载

  如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。

  ```java
  public class Hungry {
      private Hungry(){
      }
      private final static Hungry HUNGRY=new Hungry();
      public static Hungry getInstance(){
          return HUNGRY;
      }
  }
  ```

- 懒汉模式：延迟加载，只有使用的时候才会加载。 并且有**线程安全**的考量
  使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化， 但是在第一次调用的时候，会进行实例化操作，感觉上就略

  并发时不安全

  ```java
  public class Lazy {
      private Lazy(){
      }
      public static Lazy lazy;
      public static Lazy getInstance(){
          if (lazy == null) {
              lazy = new Lazy();
          }
          return lazy;
      }
  }
  ```

- 双重检测锁(DCL)模式的懒汉模式

  ```java
  public class Lazy {
      private Lazy(){
          System.out.println(Thread.currentThread().getName());
      }
      public static Lazy lazy;
      //public volatile static Lazy lazy;  加入volatile可以避免重排，更安全
      public static Lazy getInstance(){
          if (lazy == null) {  //一次检测
              synchronized (Lazy.class){
                  if (lazy == null) {  //二次检测
                      lazy = new Lazy();  //不是原子操作，任然不安全，除非加入volatile
                  }
              }
          }
          return lazy;
      }
  ```

- 枚举：反射可以破坏单例模式，但反射不能破坏枚举

### 4. CAS

- Conmpare And Set，是CPU的并发原理
- Unsafe类：全是native方法，用于直接操作内存
- 比较当前工作内存中的值和主存中的值，如果这个值是期望的，就执行操作，否则就一直循环(阻塞)等待
- 缺点：循环会耗时、一次只能保证一个共享变量的原子性以及ABA问题
- ABA问题：狸猫换太子

### 5. 原子引用

- 即带版本号的原子操作，可以解决ABA问题
- 对应思想为乐观锁

## 16.各种锁的理解

### 1. 公平锁和非公平锁

- 公平锁：不能插队，先来先执行
- 非公平锁：可以插队，默认为非公平锁

### 2. 可重入锁

- 又称为递归锁
- 拿到外层锁后会**自动**获得内层的锁

### 3. 自旋锁

- 不断尝试直到成功为止

### 4. 死锁

- 如何排查解决问题：

  1. 使用`jps -l`定位进程号

     ![](https://s3.bmp.ovh/imgs/2022/01/bb326a3d3761b0c3.png)

  2. 使用`jstack 进程号` 查看堆栈信息，找到死锁问题

     ![](https://s3.bmp.ovh/imgs/2022/01/d4ed8acf84ee7702.png)

# 7. 集合类

## 1. 集合

### 1. 优点

- 可以动态保存任意多个对象，使用比较方便
- 提供一系列方便的操作对象的方法：add、remove、set、get等

### 2. 分类

- Collection单列集合：
  - List：ArrayList，LinkedList，Vector
  - Set：HashSet，TreeSet
- Map双列集合：
  - HashMap<--LinkedHashMap
  - TreeMap
  - Hashtable<--Properties

## 2. Collection

### 1. Collection接口简介

- Collection的实现子类可以存放多个元素，每个元素可以是Object
- Collection的实现子类中List可以存放重复元素、有序，Set不行、无序
- Collection接口没有直接实现子类，是通过它的子接口List和Set来实现的
- 常用方法：add，remove，contains，size，isEmpty，clear，addAll，containsAll，removeAll

### 2. Interator(迭代器)和for

- Interator对象称为迭代器，主要用于遍历Collection集合中的元素

- 所有实现了Collection接口的集合类都有一个interator()方法，用于返回一个实现了Interator接口的对象，即一个迭代器

- Interator仅用于遍历集合，Interator本身不含对象

  ```java
  Iterator<Book> iterator=list.iterator();//获得迭代器
          while (iterator.hasNext()){ //看下一个还有没有
              System.out.println(iterator.next());  //输出下一个
          }  //最开始时iterator.next()指向第一个(index 0的元素)
  ```

- 增强for循环：简化版的iterator，本质一样，只能用于遍历集合和数组

  ```java
  for (Book book : list) {//增强for循环
              System.out.println(book);
          }
  ```

## 3. List

### 1. List接口简介

- 有序(添加和取出的顺序一致)，可重复
- 每个元素都有其对应的顺序索引，即支持索引
- 每个元素都对应一个整数型的序号记载其在容器里的位置，可以根据序号存取容器中的元素

### 2. 常用方法

- add，addAll，get，indexOf，lastIndexOf，remove
- set(int index,Object ele)：将index处的元素设置为ele，相当于替换
- subList(int fromIndex,int toIndex)：设subList(0，2)返回的就是0，1两个元素

### 3. 三种遍历方式

- 迭代器，增强for循环，普通for循环

  ```java
  for (int i = 0; i < list.size(); i++) {  //普通for循环
              System.out.println(list.get(i));
          }
  ```

- 使用流来排序

  ```java
  List<Book> list = new ArrayList<Book>();
          list.add(new Book("傲慢与偏见","简·奥斯汀",21));
          list.add(new Book("战争与和平","列夫·尼古拉耶维奇·托尔斯泰",12));
          list.add(new Book("红与黑","司汤达",33));
          list.add(new Book("红楼梦","曹雪芹",14));
          list.add(new Book("动物庄园","乔治·奥威尔",10));
  Stream<Book> stream=list.stream();
          stream.sorted(Comparator.comparing(Book::getPrice).reversed())
                  .forEach(System.out::println);
  ```

### 4. ArrayList

- 元素可以为null，多个也都可以为null
- 是由数组实现存储
- 基本等同于Vector，除了ArrayList为线程不安全(参见6.5.1)、执行效率高。多线程下不建议使用ArrayList
- 源码分析
  - ArrayList维护了一个Object类型的数组elementData
  - 当创建ArrayList时，如使用的是无参构造器，则初始容量为0，第一次添加时扩容至10，如需再次扩容，则扩容至1.5倍
  - 使用有参构造时，只有扩容就是1.5倍

### 5. Vector

- 底层也是一个Object对象数组

- 是线程同步的，即线程安全，Vector类的操作方法带有synchronized关键字

- 和ArrayList对比

  |           | 底层结构 | 版本 | 线程安全和效率 | 默认容量和扩容倍数 |
  | :-------: | :------: | :--: | :------------: | :----------------: |
  | ArrayList | 可变数组 | 1.2  | 不安全，效率高 |      10，1.5       |
  |  Vector   | 可变数组 | 1.0  |  安全，效率低  |       10，2        |

### 6. LinkedList

- 实现了双向链表和双端队列特点

- 可以添加任意元素，包括null

- 线程不安全

- 添加和删除对象时效率及其高

- 源码分析

  - 底层维护了一个双向链表

  - Node first和Node last分别指向首节点和尾节点

  - 每个Node对象中，item为存储的元素，pre指向前一个Node，next指向下一个Node

    ```java
    private static class Node<E> {
            E item;
            Node<E> next;
            Node<E> prev;
            Node(Node<E> prev, E element, Node<E> next) {
                this.item = element;
                this.next = next;
                this.prev = prev;
            }
        }
    ```

## 4. Set

### 1. Set接口简介

- 无序(添加和取出的顺寻不一定一致，但取出顺序是固定的，不是随机的)，没有索引
- 不允许重复元素，允许null，但最多一个
- 不可以使用索引方式(即一般for循环)遍历

### 2. HashSet

- 底层维护了一个HashMap(HashMap的底层是数组+链表+红黑树)
- 重复元素的定义为hashCode相同且equals==true，而不是属性值相同
- 源码分析
  - 默认大小为16(因为HashMap默认大小为16)，每次扩容变成下一个2^n个(16扩容至32，原因同前)
  - 每次add是向HashMap添加一个Key为e(要添加的元素)，vlaue为定值(`private static final Object PRESENT = new Object();`)的键值对
  - value使用static final的好处是多个对象使用一份内存空间，减少内存消耗
  - 当添加一个元素时，首先会得到hashCode，用哈希值作为索引值查找table数组，如果此位置没有元素，则直接加入，否则调用equals比较，如果相同，就放弃添加否则加到链表后；如果一条链表的元素个数>=8，并且table的大小>=64时会进行树化(红黑树)
  - 因为底层是HashMap，所以源码关键在于HashMap，此处不展开过多

### 3. LinkedHashSet

- 为HashSet的子类
- 根据元素的hashCode来决定元素的存储位置，同时使用链表维护元素次序，使得元素看起来像是以插入顺序保存的
- 底层是一个LinkedHashMap(LinkedHashMap的底层为数组+双向链表)

## 5. Map

### 1. Map接口简介

- Map用于保存具有映射关系的key-value键值对
- key和value可以是任何引用类型和null，会被封装为Node类型
- key不允许重复(原因参见源码分析)，value可以重复；再次put同样的key为更新value值
- 只能通过key找到value而不能通过value找到key
- 为了方便遍历，底层会创建entrySet集合(`transient Set<Map.Entry<K,V>> entrySet;`)，该集合并没有存储数据，存储的只是指向key或value的指针
- entrySet集合实际存储的是Node类型
- EntrySet的entrySet只是一种封装，类似的还有KeySet类的keySet和Values的collection(三种类都是HashMap的内部类)

## 6. HashMap

### 1. HashMap简介

- 底层为数组+链表+红黑树(均为Node类型)
- 加载因子用于计算临界值，当size超过临界值时，就会扩容。临界值=加载因子(默认0.75)*最大值
- Node属性

```java
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
```

- HashMap的size为所有Node的数量，不是table中的已经使用的位置
- **hash()得出的hash不等同于hasCode**

### 2. 扩容和树化

- 第一次添加时，table数组扩容到16；如果size大于等于临界值12，就会扩容到16*2=32，新的临界值为24，再次扩容就是64，以此类推
- 默认情况下，一条链上的元素个数大于等于8**并且**table的大小大于等于64，就会进行树化，树化的对象是链表而不是整个HashMap
- TreeNode

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // red-black tree links
        TreeNode<K,V> left;
        TreeNode<K,V> right;
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
```

### 3. 源码分析

- 底层维护了一个Node数组table
- 执行put()前会执行hash()，该方法返回的并不是hashCode，而是右移16位后的异或

```java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

- put()会把hashKey和key、value丢入putVal方法，后者才真正执行put操作

```java
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

- resize()会给予table默认大小(table为空时)或使其大小翻倍
- putVal()首先会定义一个Node数组tab，并定义变量n

```java
Node<K,V>[] tab;Node<K,V> p; int n, i;
if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
```

​		根据传进来的hash取计算key应该存放到table的哪个位置，并把这个位置的对象赋		值给p(p为索引位置链表的第一个Node)，如果p<font color="yellow">为空</font>，则创建一个Node放入需要		存入的key-value(和hash)

```java
if ((p = tab[i = (n - 1) & hash]) == null)  //按位与不会超过原数，即索引不会大于数组长度
            tab[i] = newNode(hash, key, value, null);
```

​		如果<font color=yellow>不为空</font>：

```java
            Node<K,V> e; K k;   //先创建一个临时变量Node e
            if (p.hash == hash &&  //如果p的hash等于待添加Node的hash
                ((k = p.key) == key || (key != null && key.equals(k))))
                //前面判断是不是同一个对象(hashCode相同)，后面判断两个对象内容是否相同(equals==true)
                    e = p;
            else if (p instanceof TreeNode)  //再判断p是否为一棵红黑树
                    e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                                     //putTreeVal为红黑树的节点添加方法
            else {//不是同一个对象且内容不同且p不是红黑树
                    for (int binCount = 0; ; ++binCount) {  //遍历链表
                        if ((e = p.next) == null) {  //如果遍历完或链表只有p
                        p.next = newNode(hash, key, value, null);  //直接加p后面
                                if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                                    //TREEIFY_THRESHOLD为8，大于等于就要树化
                                    treeifyBin(tab, hash);  //转化成红黑树
                                break;//遍历完了break
                            }
                        if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                            //是否相同或相等，参见第4行注释
                            break;//找到相同break
                        p = e;  //向后移动一个(参见第11行e=p.next)
                    }//for在这里结束
            }//else在这里结束
    
            if (e != null) { // existing mapping for key
                //走else时e==null
                V oldValue = e.value;   
                if (!onlyIfAbsent || oldValue == null)  //oldValue==null再次判断
                    //onlyIfAbsent为真表示不更改现有值
                    e.value = value;  //更新值
                afterNodeAccess(e);  //留给子类拓展的方法
                return oldValue;  //把已经存在的Node(p)的值返回，表示失败
            }
```

​		加入完毕后检查是否超过临界值，是则resize()

​		最后留了一个空方法给子类拓展，返回null
- 树化treeifyBin()

  如果tab.length<64，并不会树化，而是执行resize()扩容

### 4. LinkedHashMap

- 为HashMap的子类,底层为数组(HashMap.Node数组，但存放的是LinkedHashMap.Entry)+双向链表(Entry链表)

- 节点Entry属性

  ```java
  static class Entry<K,V> extends HashMap.Node<K,V> {
          Entry<K,V> before, after;
          Entry(int hash, K key, V value, Node<K,V> next) {
              super(hash, key, value, next); //调用父类HashMap.Node的构造函数
          }
      }
  ```

- 1



## 


















