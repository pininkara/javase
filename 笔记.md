# 1. 注解和反射

## 1. 注解

## 2. 反射

# 2. 多线程

## 1. 线程基础

 ### 1. 实现方式

1. 继承Thread类

   - 子类继承Thread类具备多线程能力

   - 启动线程：子类对象.start()

     ```java
       testThread1.start();
     ```

   - <font color="red">不建议使用：避免单继承局限性</font>

2. 实现Runnable接口

   - 实现接口Runnable具有多线程能力

   - 启动线程：传入目标对象+Thread对象.start()

     ```java
     new Thread(testThread3).start();
     ```

   - 前期建议使用：灵活方便，同一个对象可以被多个线程使用

3. 实现Callable接口（拓展）

   - 实现Callable接口，需要返回值类型
   - 重写call方法，需要抛出异常
   - 四个步骤：创建执行服务->提交执行->获取结果->关闭服务
   - 优点：可以定义返回值，可以抛出异常
   - 缺点：复杂
   - 后期主要使用该方法



 ### 2. 静态代理

- 真实对象和代理对象都要实现同一个接口
- 代理对象要代理真实角色
- 优点：
  - 代理对象可以做很多真实对象做不了的事情
  - 真实对象专注自己的事情

 ### 3. Lambda表达式

- 函数式接口：如果一个接口只包含唯一一个抽象方法，那它就是一个函数式接口。对于函数式接口，我们可以用Lambda表达式来创建该接口的对象

  ```java
  love = a -> System.out.println("I love you-->" + a);
  ```
  

## 2. 线程状态

 ### 1. 线程的五个状态

1. 创建状态
2. 就绪状态
3. 阻塞状态
4. 运行状态
5. 死亡状态

 ### 2. 停止线程

- 不推荐使用stop()和destroy()方法（已弃用）
- 推荐让线程自己停下来，如设置一个标志位flag，当flag=false时，线程终止运行,或使用指定运行次数

 ### 3. 线程休眠

- sleep不会释放锁

 ### 4. 线程礼让

- 礼让线程：让当前正在执行的线程暂停，但不阻塞；即让线程从运行状态转化为就绪状态
- 礼让不一定成功，取决于CPU

 ### 5. Join

- Join合并线程，将此线程执行完毕后，再执行其他线程。该线程执行完毕前，其他线程阻塞，可以想象为插队

 ### 6. 线程优先级

- 线程调度按照优先级决定应该调度哪个线程来执行

- 优先级用数字表示，范围从1~10

  ```java
   //预定义常量
   Thread.MIN_PRIORITY = 1;
   Thread.MAX_PRIORITY = 10;
   Thread.NORM_PRIORITY = 5;
  ```

- 可以用getPriority()和setPriority()来获取和改变线程优先级

- 优先级只是参考，实际执行效果还是取决于CPU

 ### 7. 守护线程

- 线程分为用户进程和守护进程

- JVM必须确保用户进程执行完毕，而不用等待守护线程执行完毕

- 守护线程的例子：后台记录操作日志，监控内存，垃圾回收等

- 设置方法

  ```java
  thread.setDaemon(true);//默认为false表示用户线程
  ```

## 3. 线程同步

 ### 1. 并发

- 同一个对象被多个线程同时操作

### 2. 线程同步

- 处理多线程问题时，多个线程访问同一个对象，需要线程同步机制

- 线程同步其实是一种等待机制，多个需要同时访问此对象的线程进入这个<font color="red">对象的等待池</font>形成队列，等待前面的线程使用完毕，下个线程再使用

- 线程同步还需要锁：为保证数据在方法中被访问时的正确性，在访问时加入<font color="red">锁机制synchronized</font>，当一个线程获得对象的排他锁、独占资源时，其他线程必须等待，使用后释放锁即可

- 锁机制可能会导致以下问题
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起
  - 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延迟，引起性能问题
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置

### 3. 同步方法

  - synchronized方法控制对象的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞。方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行

    ```java
    public synchronized void method(){}
    ```

  - 缺点：synchronized方法会影响其效率

  - synchronized锁的对象为变化的量，依据实际问题会用到同步方法和同步块

### 4. 同步块

  - Obj称之为同步监视器

    - Obj可以是任何对象，推荐用共享资源作为同步监视器
    - 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是本身或Class

    ```java
    synchronized(Obj){}
    ```

  - 同步监视器执行过程

    1. 第一个线程访问，锁定同步监视器，执行其中的代码
    2. 第二个线程访问，发现同步监视器被锁定，无法访问
    3. 第一个线程访问完毕，解锁同步监视器
    4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问
    
  - JUC包里的线程安全类型

### 5. 死锁

  - 产生死锁的四个必要条件
    - 互斥
    - 请求与等待
    - 不可剥夺
    - 循环等待
  - 只需破坏四个条件中的一个或多个即可避免死锁

### 6. 锁

  - 通过显示定义同步锁对象来实现同步。同步锁使用Lock对象充当
  - java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问资源之前先获得Lock对象
  - ReentranLock(可重入锁)类实现了Lock，它拥有与synchroized相同的并发性和内存语义，在线程安全的控制中，比较常用的是ReentrantLock，可以显示加锁、释放锁
  - synchronized与Lock对比
    - Lock是显示锁（手动开启和关闭锁，**切记要关闭锁**），synchronized是隐式锁，出了作用域自动释放
    - Lock只有代码块锁，synchronized有代码块锁和方法锁
    - 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）
    - 优先使用顺序：Lock>同步代码块（已经进入方法体，分配了相应资源）>同步方法（在方法体之外）

## 4. 线程协作与通信

### 1. 生产者消费者模式

- 生产者和消费者共享同一个资源，并且生产者和消费者直接相互依赖，互为条件
- 在生产者消费者问题中，仅有synchronized是不够的
  - synchronized可阻止并发更新同一个共享资源，实现了同步
  - synchronized不能用来实现不同线程之间的消息传递（通信）
- 解决方法：
  - 建立一个缓冲区，生产者将产品放入，消费者将产品取出（管程法）
  - 设置一个标志位，true生产，false等待（信号灯法）

### 2. 线程通信问题的方法

- Java提供了几个方法解决线程直接的通信问题

  | 方法名 | 作用 |
  | :----: | :----: |
  |  wait()| 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁 |
  | wait(long timeout) | 指定等待的毫秒数 |
  | notify() | 唤醒一个处于等待状态的线程 |
  | notifyAll() | 唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度 |
  
- 注意：以上均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException

## 5. 线程池

### 1. 线程池

- 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大
- 思路：提起创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁线程，实现重复利用，类似生活中的公共交通工具
- 好处：
  - 提供相应速度
  - 降低资源消耗
  - 便于线程管理

### 2. 使用线程池

- 线程池核心参数
  - corePoolSize：核心池的大小
  - maximumPoolSize：最大线程数
  - keepAliveTime：线程没有任务时最长保持多长时间后会终止
- 相关API：ExecutorService和Executors
  - ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor
  - Exrcutors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池

# 3. 网络编程

## 1. 计算机网络概述

- ip，端口号：TCP和UDP使用两套不同的端口号，都是0~65535

  ```bash
  netstat -ano  #查看所有端口
  netstat -ano | findstr 8080  #查找指定端口
  tasklist | findstr 8696  #查看指定PID的进程
  ```

- 协议

## 2. TCP实现聊天

### 1. 客户端

1. 连接服务器Socket
2. 发送消息

### 2. 服务端

1. 建立服务的端口ServiceSocket
2. 等待用户连接accept()（阻塞式监听）
3. 接收用户消息

## 3. TCP实现文件上传

## 4. UDP

- UDP并没有严格的客户端服务端区分

## 5. URL

- 协议://ip:端口/项目名/资源

# 4.IO流

## 1. 文件

### 1. 文件

- 保存的数据

### 2. 文件流

- 文件再程序中是以流的形式来操作的

- 输入流：数据从数据源(文件)到程序(内存)的路径

  输出流：数据从程序(内存)到数据源(文件)的路径

## 2. IO流

### 1. IO流原理

- Java程序中，对于数据的输入/输出操作以流(stream)的方式进行
- Java.io包中提供了各种流的类和接口，用以获取不同种类的数据，并通过方法输入或输出数据

### 2. 流的分类

- 字节流：按8bit(一字节)为单位

  字符流：按字符为单位

- Java的IO流都是由一下4个抽象基类产生

  | 抽象基类 | 字节流 | 字符流 |
  | :----: | :----: |:----:|
  | 输入流 | InputStream | Reader |
  | 输出流 | OutputStream | Writer |

- 字符流是字符操作的，只能用于文本文件，其他文件可能会造成文件损坏

  使用字节流操作文本文件则可能造成乱码(拷贝时不会)

- 节点流：从一个特定的数据源读写数据，如FileReader、FileWriter

  处理流：也叫包装流，是连接已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，如BufferedReader、BufferedWriter

- 处理流的优点：

  - 提高性能：可以增加缓冲来提供输入输出的效率
  - 操作便捷：提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便

### 3. 常见流

- 对象处理流：

  - 序列化和反序列化

  - 某个对象支持序列化机制，必须让其类是可序列化的，即该类必需实现Serialized(推荐使用，标记接口，内部无方法)或Externalizable两个接口中的任一个

  - 使用ObjectOutputStream、ObjectInputStream进行序列化、反序列化

  - static和transient修饰的成员默认不会被序列化，其他属性也可以通过transient关键字使其不被序列化

  - 序列化具备可继承性，即子类默认也会实现序列化

  - 可以添加serialVersionUID(序列化版本号)提供兼容性，添加后会被认为是版本修改而不是全新的类

    ```java
    private static final long serialVersionUID = 1L;
    ```

  - 反序列化时需要向下转型，反序列化时的类需要有访问权限

  - 反序列化的顺序要和序列化时一致

- 标准输入输出流

  |  | 编译类型 | 运行类型 | 默认设备 |
  | :--: | :----: | :----: | :----: |
  | System.in | InputStream | BufferedInputStream | 键盘 |
  | System.out | PrintStream | PrintStream | 显示器 |

- 转换流

  - InputStreamReader和OutputStreamWriter
  - 把字节流转换为字符流
  - 字符流不能指定编码，通过这种方式可以得到指定编码的字符流

- 打印流

  - PrintStream和PrintWriter
  - 打印流只有输出流没有输入流
  - PrintStream使用的是write()方法，默认情况下输出位置为标准输出
  - System.out.println();中的out就是System类中的一个PrintStream常量

## 3. <span id="4.3">Properties类</span>

### 1. Properties配置文件

- 配置文件格式

  键=值

  键=值

- 键值对不需要有空格，值不需要使用引号，值的默认类型为String

### 2. Properties类常见方法

- load：加载配置文件键值对到Properties对象
- list：将数据显示到指定设备
- getProperties(key)：根据键获取值
- setProperties(key,value)：设置键值对到Properties对象
- store：将Properties对象存储到配置文件，使用字节流时有中文会保存为Unicode码

# 5. JVM基础

## 1. JVM探究

### 1. 常见面试题

- Java8虚拟机和之前的变化
- OOM，StackOverFlow
- JVM的常用调优参数
- 内存快照和Dump文件
- 类加载器

### 2. 常见概念

- JVM的位置、JVM的体系结构
- 类加载器
- 双亲委派机制、沙箱安全机制
- Native
- PC寄存器
- 方法区、栈(存地址)、堆(存地址对应的属性和值)
- 三种JVM
- 新生区、老年区、永久区
- 堆内存调优
- GC(垃圾回收)
- JMM(Java内存模型)

## 2. JVM的体系结构

- JVM的位置：JVM介于操作系统和Java程序之间
- JVM是用C写的
- 体系结构图 <img src="https://i.bmp.ovh/imgs/2022/01/cc59183ebe020510.png"  />
- 栈和PC都不会有垃圾，JVM调优在堆里调（方法区是特殊的堆）

## 3. JVM的组件

### 1. 类加载器

- 作用：加载Class文件

- 步骤

  ![](https://s3.bmp.ovh/imgs/2022/01/6a4f76a564b524ca.png)

- 类加载器的分级

  - JVM的类加载器
  - 启动类(根)加载器
  - 扩展类加载器
  - 应用程序(系统类)加载器


### 2. 双亲委派机制

- 运行类时会先从下往上找类加载器中的类，如果多个加载器中都有类，最后会执行的类是上级加载器中的类
- 作用：保证安全
- 步骤：
  1. 类加载器收到类加载的请求
  2. 将这个请求向上委托给父类加载器完成
  3. 启动加载器检查是否能够加载当前类，能加载就结束，否则抛出异常通知子加载器进行加载
  4. 子类加载器重复步骤3

### 3. 沙箱安全机制

- 将Java代码限定在JVM虚拟机特定的运行范围中，并且严格限制代码对本地系统资源的访问
- 沙箱的基本组件：
  - 字节码校验器：确保Java类文件遵顼Java语言规范，可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类
  - 类加载器：防止恶意代码区干涉善意代码；守护被信任的类库边界；将代码归入保护域，确定了代码可以进行哪些操作
  - 存储控制器：控制核心API对操作系统的存取权限，可以由用户指定控制策略
  - 安全管理器：核心API和操作系统间的主要接口，实现权限控制，比存储控制器优先级高
  - 安全软件包：java.security下的类及其扩展包下的类，允许用户为自己的应用增加新的安全特性，包括安全提供者、消息摘要、数字签名(KeyTools)、加密、鉴别等

### 4. Native

- native关键字表明超出了Java的作用范围，需要调用C语言库，会进入本地方法栈，调用本地方法接口JNI。以便融合不同编程语言，为Java使用
- Java诞生时C/C++横行，想要立足，必须能调用C/C++的程序，于是便专门在内存中开辟一块标记区域：Native Method Strack来登记Native方法
- 最终执行时，加载本地方法库中的方法需通过JNI

### 5. 程序计数器PC

- 每一个线程都有一个PC，是线程私有的，本质是一个指针，指向方法区的字节码
- 用来存储指向下一条指令的地址，也就是即将要执行的指令代码，以便执行引擎读取下一条指令
- 是一个非常小的内存地址，几乎可以不计

### 6. 方法区

- 方法区被所有线程共享，此区域属于共享区间
- 所有字段、方法字节码、接口以及一些特殊方法（如构造函数）也再次定义。简单说，所有定义的方法的信息都保存在该区域
- 静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池也存放在方法区中，<font color="yellow">但实例变量存在堆内存中，和方法区无关</font>

### 7. 栈

- 栈内存，主管程序运行，生命周期和线程同步
- 线程结束，栈内存释放。对于栈来说，不存在垃圾回收
- 栈的内容：8大类型、对象引用、实例方法
- 栈运行原理：栈帧，一个方法产生一个栈帧，执行最上面的方法

### 8. 堆

- 一个JVM只有一个堆内存
- 堆内存的大小是可以调节的
- 类加载器读取类文件后，会把变量放在堆区
- 堆分为三个区域：
  - 新生区：又分为伊甸园区(类诞生和成长甚至死亡的地方，所有的对象都在这里new出来)和幸存者区(一般有两个，以0、1标识，0就是from、1是to，活过垃圾回收的会进入这里)
  - 养老区
  - 永久区(JDK8以后叫元空间)：常驻内存，用来存放JDK自身的Class对象、Interface元数据，存储的是Java运行时的一些环境或类信息。不存在垃圾回收，关闭虚拟机就会释放内存。使用的是物理机的内存，不是JVM的内存
- GC主要是在新生区和养老区
- 堆内存满了会报OOM，可以使用MAT和Jprofiler等分析Dump文件，快速定位内存泄漏

### 9. 三种JVM

- Sun HotSpot
- BEA JRockit
- IBM J9VM

### 10. GC及其常用算法

- GC两种类型：轻GC和重GC(全局GC)

- 常用算法：

  - 标记清除法

    ![](https://s3.bmp.ovh/imgs/2022/01/e9d6f1f54014ae16.png)

  - 标记压缩法

    ![](https://s3.bmp.ovh/imgs/2022/01/76a2b5d5c182905d.png)

  - 复制算法

    将存活的对象复制到to区，然后清空from区(谁是空的谁是to区，谁不是空的谁是from区)

  - 分代收集法

    分为新生代和老年代，新生代用复制算法，老年代用标记压缩法

  - 总结：

    - 内存使用次数：复制算法(一次)<标记清除法(两次)<标记压缩法(多次)
    - 内存整齐度：复制算法=标记压缩法>标记清除法
    - 内存利用率：标记压缩法=标记清除法>复制算法

# 6. JUC并发

## 1. JUC简介

### 1. 什么是JUC

- JUC是java.util .concurrent工具包的简称，这是一个处理线程的工具包

### 2. 回顾多线程

- Runnable：没有返回值，效率相对Callable较低
- 线程和进程：Java默认有两个进程(main和GC)

### 3. 并发和并行

- 并行：多个进程干同样的事(要求多核CPU)
- 并发：多个线程操作同一个资源
- 并发编程的本质：<font color="yellow">充分利用CPU资源</font>

## 2. 线程

### 1. 线程状态

- 新生：new
- 运行：runnable
- 阻塞：blocked
- 等待：watting
- 超时等待：time_watting
- 终止：terminated

### 2. waith和sleep的区别

- 来自不同的类：wait来自Object，sleep来自Thread
- 锁的释放不同：wait会释放锁，sleep不会释放锁
- 使用范围不同：wait只能在同步代码块中，sleep可以在任何地方使用
- 是否需要捕获异常：wait无需捕获异常，sleep需要捕获异常

### 3. Lock锁

- synchronized和Lock锁的区别：
  - synchronized是一个关键字，Lock是一个类
  - synchronized无法判断获取锁的状态，Lock可以判断是否获取到了锁
  - synchronized会自动释放锁，Lock必须手动释放锁，否则会导致死锁
  - synchronized会导致后续线程等待，Lock后续线程可以超时等待
  - synchronized为非公平锁、可重入的(线程已经获得某个锁，可以再次获取锁而不会出现死锁)，Lock可以设置为公平锁、可重入、可以判断锁
  - synchronized适合少量的代码同步问题，Lock适合大量的代码同步
- 公平锁和非公平锁：非公平锁允许插队，默认为非公平锁
- 可重用锁ReentrantLock

## 3. 生产者和消费者问题

### 1. synchronized解决方案

- wait和notify

  ```java
  this.wait();
  this.notifyAll();
  ```

- 使用while可以避免多个线程时虚假唤醒问题，但多个线程依然不能依次有序进行

### 2. JUC解决方案

- await和signal

  ```java
  condition.await();
  condition.signalAll();
  ```

- 可以精准通知和唤醒进程，以便让多个线程依次有序进行

## 4. 8锁现象(8个锁有关的问题)

1. 多个线程使用同一个对象，多个线程就是使用一把锁，先调用(先拿到锁)的先执行
2. 多个线程使用同一个对象，多个线程就是使用一把锁，先调用(先拿到锁)的先执行,即使在某方法中设置了阻塞
3. 多个线程，有的线程有锁，有的线程没锁，两者之间不存在竞争同一把锁的情况，先后执行顺序是随机的
4. 多个线程使用多把锁-随机执行
   - 被 synchronized 修饰的方法，锁的对象是方法的调用者
   - 调用者不同，它们之间用的不是同一个锁，相互之间没有关系。
5. Class锁：多个线程使用一个对象-顺序执行

   - 被 synchronized 和 static 同时修饰的方法，锁的对象是类的 class 对象，是唯一的一把锁，线程之间是顺序执行
   - 锁Class和锁对象的区别：
     - Class 锁 ，类模版，只有一个
     - 对象锁 ， 通过类模板可以new 多个对象
   - 如果全部都锁了Class，那么这个类下的所有对象都具有同一把锁
6. Class锁：多个线程使用多个对象-顺序执行
   - 被 synchronized 修饰 和 static 修饰的方法，锁的对象是类的 class 对象，是唯一的一把锁
   - Class锁是唯一的，所以多个对象使用的也是同一个Class锁
7. Class锁与对象锁：多个线程使用一个对象-随机执行
   - 被 synchronized和static修饰的方法，锁的对象是类的class对象，唯一的同一把锁
   - 只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰
8. Class锁与对象锁：多个线程使用多个对象-随机执行
   - 被 synchronized和static修饰的方法，锁的对象是类的class对象
   - 只被synchronized修饰的方法，是普通锁（如对象锁），不是Class锁，所以进程之间执行顺序互不干扰

## 5. 安全集合类

### 1. <span id=6.5.1>List</span>

- 可以更换Vector，Vector是安全的，但不推荐，Vector快被弃用了

- 推荐使用JUC工具类使其变得安全

  ```java
  List<String> list= Collections.synchronizedList(new ArrayList<>());
  ```

- 也可以使用CopyOnWriteArrayList

  ```java
  List<String> list= new CopyOnWriteArrayList<>();
  ```

- CopyOnWrite写入时复制(COP)，是计算机程序设计领域中的一种通用优化策略

  - 其核心思想是，如果有多个调用者（Callers）同时访问相同的资源（如内存或者是磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源
  - 直到某个调用者修改资源内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变，这过程对其他的调用者都是透明的（transparently）
  - 此做法主要的优点是如果调用者没有修改资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源
  - COP效率高

### 2. Set

- JUC工具类

  ```java
  Set<String> set = Collections.synchronizedSet(new HashSet<>());
  ```

- COP

  ```java
  Set<String> set = new CopyOnWriteArraySet<>();
  ```

- HashSet的底层为HashMap，HashSet的add的就是map的key(因为key要求不能重复所以HashSet不可重复，value则为一个常量)

### 3. Map

- 默认值：初始化容量，加载因子

  ```java
  Map<String,String> map=new HashMap<>();
  Map<String,String> map1=new HashMap<>(16,0.75);//两行代码等价
  ```
  一般工作中不会这样new HashMap

- JUC工具类

  ```java
  Map<String,String> map= Collections.synchronizedMap(new HashMap<>());
  ```

- 并发HashMap

  ```java
          Map<String,String> map= new ConcurrentHashMap<>();
  ```

## 6. Callable

### 1. Callable简介

- 可以有返回值，可以抛出异常
- 有缓存，效率高
- 可以使用futureTask.get()获取返回值，此方法可能会产生阻塞，记得放到最后或使用异步处理

## 7. 常用辅助类

### 1. CountDownLatch

- 减法计数器

  ```java
  CountDownLatch countDownLatch=new CountDownLatch(6);//计数器设置为6
  countDownLatch.countDown();//计数器减1
  
  countDownLatch.await();//等待计数器归零，在主线程里使用，会阻塞主线程
  ```

### 2. CyclicBarrier

- 加法计数器

  ```java
  CyclicBarrier cyclicBarrier = new CyclicBarrier(7,()->{
              System.out.println("执行成功");
          });//计数器设置为7，设置执行完毕后的线程
  cyclicBarrier.await();//等待达到计数器，在子线程里使用，会阻塞所有子线程
  ```

### 3. Semaphore

- 信号量，限制并发线程数量

  ```java
   Semaphore semaphore=new Semaphore(3);  //可用资源数3
          for (int i = 0; i < 6; i++) {
              new Thread(()->{
                  try {
                      semaphore.acquire();//获取资源，获取不到则阻塞
                      TimeUnit.SECONDS.sleep(3);
                  } catch (Exception e) {
                      e.printStackTrace();
                  }finally {
                      semaphore.release();//释放资源
                  }
              }).start();
          }
  ```

## 8. 读写锁

- 写锁(独占锁)和读锁(共享锁)

  ```java
  lock.writeLock().lock();   //写锁
  lock.writeLock().unlock();
  
  lock.readLock().lock();  //读锁
  lock.readLock().unlock();
  ```

  

## 9. 队列

### 1. 阻塞队列

- 写入：队列满了必须阻塞等待
- 读取：如果队列为空，必须阻塞等待生产
-  使用阻塞队列的情况：多线程并发和线程池

### 2. 四组API

|    方式    | 抛出异常 | 不抛异常，有返回值 | 阻塞等待 | 超时等待 |
| :--------: | :------: | :----------------: | :------: | :------: |
|    添加    |   add    |       offer        |   put    |  offer   |
|    移除    |  remove  |        poll        |   take   |   poll   |
| 判断队列首 | element  |        peek        |    -     |    -     |

### 3. 同步队列

- 阻塞队列的子类
- 容量为一，放入一个元素后，必须等待取出后才能再放一个元素
- 对应操作为put和take

## 10. 线程池

### 1. <span id=6.10.1>池化技术</span>

- 创建和销毁会销毁大量资源
- 线程池，连接池，内存池，对象池，字符常量池

### 2. 线程池

- 线程复用，最大并发控制，线程管理
- 好处：降低资源消耗、提供响应速度、方便管理

### 3. Executors工具类

- 3大方法

  ```java
  Executors.newSingleThreadExecutor();//单个线程线程池
  Executors.newFixedThreadPool(6);//固定大小线程池
  Executors.newCachedThreadPool();//大小可变线程池
  ```

- 7大参数

  ```java
  public ThreadPoolExecutor(int corePoolSize,  //核心(最小)线程池大小
                                int maximumPoolSize,  //最大核心线程大小
                                long keepAliveTime,  //无人调用就释放的超时时间
                                TimeUnit unit,  //超时时间单位
                                BlockingQueue<Runnable> workQueue,  //阻塞队列
                                ThreadFactory threadFactory,  //线程工厂，用于创建线程
                                RejectedExecutionHandler handler){}  //拒绝策略
  ```
  工作中常用自定义线程

- 4种拒绝策略

  - DiscardPolicy：拒绝执行，不抛出异常
  - CallerRunsPolicy：交给父线程处理
  - AbortPolicy：拒绝执行，抛出异常
  - DiscardOldestPolicy：尝试和最早的竞争，成功则执行，失败则拒绝执行，也不会抛出异常

### 4. 最大线程数策略

- CPU密集型：CPU是几核就是几
- IO密集型：判断程序中IO消耗大的线程数，大于它即可

## 11. 四种函数式接口

### 1. 函数式接口

- 只有一个方法的接口
- 简化编程，框架底层大量使用
- lambda表达式，链式编程，函数式接口，Stream流式计算

### 2. Function

- 函数型接口，输入参数和返回值均有

- 输出为HelloHello

  ```java
  Function<String,String> function=s -> s+s;  //最简形态
  Function<String,String> function=(s) -> {return s+s;};  //一般形态
  Function<String,String> function=new Function<String, String>() {
              @Override
              public String apply(String s) {
                  return s+s;
              }
          };  //最初形态
  System.out.println(function.apply("Hello"));
  ```

### 3. Predicate

- 断定型接口，有一个输入参数，返回值只能为Boolean

- 输出为false

  ```java
  Predicate<String> predicate=s->s.isEmpty();  
  Predicate<String> predicate= String::isEmpty;  //方法引用
  System.out.println(predicate.test("aaa"));
  ```

### 4. Consumer

- 消费型接口，只有输入参数，没有返回值

- 输出为hello

  ```java
  Consumer<String> consumer= x -> System.out.println(x);
  consumer.accept("hello");
  ```

### 5. Supplier

- 供给型接口，没有输入参数，只有返回值

- 输出为HelloWorld

  ```java
  Supplier<String> supplier=() ->"HelloWorld";
  System.out.println(supplier.get());
  ```

## 12. Stream流式计算

### 1. Stream流式计算概念

- 集合(或数据库)只用来存储，计算交给流

### 2. 实例

```java
        User u1=new User(1,"a",21);   //id,name,age
        User u2=new User(2,"b",22);
        User u3=new User(3,"c",23);
        User u4=new User(4,"d",24);
        User u5=new User(6,"e",25);
        List<User> list = Arrays.asList(u1, u2, u3, u4, u5);

        Stream<User> stream = list.stream();
        stream.filter(user -> user.getId()%2==0)  //筛选id为偶数
                .filter(user -> user.getAge()>23)  //筛选age大于23
                .map(user -> user.getName().toUpperCase())  //name转换为大写
                .sorted((uu1,uu2)->{ return  uu2.compareTo(uu1);})  //倒序排序
                .limit(1)   //限制输出为一个
                .forEach(System.out::println);   //forEach遍历
```

## 13. Fork/Join

### 1. Fork/Join概念

- 将一个线程拆开，并行执行任务，提高效率
- 特点：工作窃取(将其他拆分线程未完成的任务窃取来执行)
- 大数据量才能更优

## 14. 异步回调

### 1. Future

- 设计初衷：对将来的某个事件的结果进行建模

## 15.JMM(Java内存模型)

### 1. JMM

- 一个概念及其约定，并无对应实体

- 把内存分为工作内存和主存

- 关于JMM的一些同步的约定：

  - 线程解锁前，必须**立即**把共享变量刷回主存
  - 线程加锁前，必须读取主存中的最新值读到工作内存中
  - 加锁和解锁是同一把锁

- 8种操作

  <img src="https://s3.bmp.ovh/imgs/2022/01/cd3774260984aaf8.png" style="zoom: 80%;" />

  - lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态
  - read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用
  - load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；
  - use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作
  - assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作
  - store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用
  - write(写入)：作用于主内存，它把store传送值放到主内存中的变量中
  - unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定
  - **注意：以上8种操作必须成对出现**(如出现read一定要有write)

### 2. volatile

- 适用于变量，解决线程不知道主存中的值已经被修改过了的问题
- volatile是Java虚拟机提供的轻量级的同步机制
- 特性：
  - 保证可见性：可见性指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
  - <font color='red'>不保证原子性</font>：原子性指一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<u>可以使用原子类保证原子性</u>
  - 禁止指令重排：即**有序性**，程序执行的顺序按照代码的先后顺序执行

### 3. 单例模式

- 饿汉模式：立即加载，无论是否会用到这个对象，都会加载

  如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。

  ```java
  public class Hungry {
      private Hungry(){
      }
      private final static Hungry HUNGRY=new Hungry();
      public static Hungry getInstance(){
          return HUNGRY;
      }
  }
  ```

- 懒汉模式：延迟加载，只有使用的时候才会加载。 并且有**线程安全**的考量
  使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化， 但是在第一次调用的时候，会进行实例化操作，感觉上就略

  并发时不安全

  ```java
  public class Lazy {
      private Lazy(){
      }
      public static Lazy lazy;
      public static Lazy getInstance(){
          if (lazy == null) {
              lazy = new Lazy();
          }
          return lazy;
      }
  }
  ```

- 双重检测锁(DCL)模式的懒汉模式

  ```java
  public class Lazy {
      private Lazy(){
          System.out.println(Thread.currentThread().getName());
      }
      public static Lazy lazy;
      //public volatile static Lazy lazy;  加入volatile可以避免重排，更安全
      public static Lazy getInstance(){
          if (lazy == null) {  //一次检测
              synchronized (Lazy.class){
                  if (lazy == null) {  //二次检测
                      lazy = new Lazy();  //不是原子操作，任然不安全，除非加入volatile
                  }
              }
          }
          return lazy;
      }
  ```

- 枚举：反射可以破坏单例模式，但反射不能破坏枚举

### 4. CAS

- Conmpare And Set，是CPU的并发原理
- Unsafe类：全是native方法，用于直接操作内存
- 比较当前工作内存中的值和主存中的值，如果这个值是期望的，就执行操作，否则就一直循环(阻塞)等待
- 缺点：循环会耗时、一次只能保证一个共享变量的原子性以及ABA问题
- ABA问题：狸猫换太子

### 5. 原子引用

- 即带版本号的原子操作，可以解决ABA问题
- 对应思想为乐观锁

## 16.各种锁的理解

### 1. 公平锁和非公平锁

- 公平锁：不能插队，先来先执行
- 非公平锁：可以插队，默认为非公平锁

### 2. 可重入锁

- 又称为递归锁
- 拿到外层锁后会**自动**获得内层的锁

### 3. 自旋锁

- 不断尝试直到成功为止

### 4. 死锁

- 如何排查解决问题：

  1. 使用`jps -l`定位进程号

     ![](https://s3.bmp.ovh/imgs/2022/01/bb326a3d3761b0c3.png)

  2. 使用`jstack 进程号` 查看堆栈信息，找到死锁问题

     ![](https://s3.bmp.ovh/imgs/2022/01/d4ed8acf84ee7702.png)

# 7. 集合类

## 1. 集合

### 1. 优点

- 可以动态保存任意多个对象，使用比较方便
- 提供一系列方便的操作对象的方法：add、remove、set、get等

### 2. 分类

- Collection单列集合：
  - List：ArrayList，LinkedList，Vector
  - Set：HashSet，TreeSet
- Map双列集合：
  - HashMap<--LinkedHashMap
  - TreeMap
  - Hashtable<--Properties

## 2. Collection

### 1. Collection接口简介

- Collection的实现子类可以存放多个元素，每个元素可以是Object
- Collection的实现子类中List可以存放重复元素、有序，Set不行、无序
- Collection接口没有直接实现子类，是通过它的子接口List和Set来实现的
- 常用方法：add，remove，contains，size，isEmpty，clear，addAll，containsAll，removeAll

### 2. Interator(迭代器)和for

- Interator对象称为迭代器，主要用于遍历Collection集合中的元素

- 所有实现了Collection接口的集合类都有一个interator()方法，用于返回一个实现了Interator接口的对象，即一个迭代器

- Interator仅用于遍历集合，Interator本身不含对象

  ```java
  Iterator<Book> iterator=list.iterator();//获得迭代器
          while (iterator.hasNext()){ //看下一个还有没有
              System.out.println(iterator.next());  //输出下一个
          }  //最开始时iterator.next()指向第一个(index 0的元素)
  ```

- 增强for循环：简化版的iterator，本质一样，只能用于遍历集合和数组

  ```java
  for (Book book : list) {//增强for循环
              System.out.println(book);
          }
  ```

## 3. List

### 1. List接口简介

- 有序(添加和取出的顺序一致)，可重复
- 每个元素都有其对应的顺序索引，即支持索引
- 每个元素都对应一个整数型的序号记载其在容器里的位置，可以根据序号存取容器中的元素

### 2. 常用方法

- add，addAll，get，indexOf，lastIndexOf，remove
- set(int index,Object ele)：将index处的元素设置为ele，相当于替换
- subList(int fromIndex,int toIndex)：设subList(0，2)返回的就是0，1两个元素

### 3. 三种遍历方式

- 迭代器，增强for循环，普通for循环

  ```java
  for (int i = 0; i < list.size(); i++) {  //普通for循环
              System.out.println(list.get(i));
          }
  ```

- 使用流来排序

  ```java
  List<Book> list = new ArrayList<Book>();
          list.add(new Book("傲慢与偏见","简·奥斯汀",21));
          list.add(new Book("战争与和平","列夫·尼古拉耶维奇·托尔斯泰",12));
          list.add(new Book("红与黑","司汤达",33));
          list.add(new Book("红楼梦","曹雪芹",14));
          list.add(new Book("动物庄园","乔治·奥威尔",10));
  Stream<Book> stream=list.stream();
          stream.sorted(Comparator.comparing(Book::getPrice).reversed())
                  .forEach(System.out::println);
  ```

### 4. ArrayList

- 元素可以为null，多个也都可以为null
- 是由数组实现存储
- 基本等同于Vector，除了ArrayList为线程不安全(参见[6.5.1](#6.5.1))、执行效率高。多线程下不建议使用ArrayList
- 源码分析
  - ArrayList维护了一个Object类型的数组elementData
  - 当创建ArrayList时，如使用的是无参构造器，则初始容量为0，第一次添加时扩容至10，如需再次扩容，则扩容至1.5倍
  - 使用有参构造时，只有扩容就是1.5倍

### 5. Vector

- 底层也是一个Object对象数组

- 是线程同步的，即线程安全，Vector类的操作方法带有synchronized关键字

- 和ArrayList对比

  |           | 底层结构 | 版本 | 线程安全和效率 | 默认容量和扩容倍数 |
  | :-------: | :------: | :--: | :------------: | :----------------: |
  | ArrayList | 可变数组 | 1.2  | 不安全，效率高 |      10，1.5       |
  |  Vector   | 可变数组 | 1.0  |  安全，效率低  |       10，2        |

### 6. LinkedList

- 实现了双向链表和双端队列特点

- 可以添加任意元素，包括null

- 线程不安全

- 添加和删除对象时效率及其高

- 源码分析

  - 底层维护了一个双向链表

  - Node first和Node last分别指向首节点和尾节点

  - 每个Node对象中，item为存储的元素，pre指向前一个Node，next指向下一个Node

    ```java
    private static class Node<E> {
            E item;
            Node<E> next;
            Node<E> prev;
            Node(Node<E> prev, E element, Node<E> next) {
                this.item = element;
                this.next = next;
                this.prev = prev;
            }
        }
    ```

## 4. Set

### 1. Set接口简介

- 无序(添加和取出的顺寻不一定一致，但取出顺序是固定的，不是随机的)，没有索引
- 不允许重复元素，允许null，但最多一个
- 不可以使用索引方式(即一般for循环)遍历

### 2. HashSet

- 底层维护了一个HashMap(HashMap的底层是数组+链表+红黑树)
- 重复元素的定义为hashCode相同且equals==true，而不是属性值相同
- 源码分析
  - 默认大小为16(因为HashMap默认大小为16)，每次扩容变成下一个2^n个(16扩容至32，原因同前)
  - 每次add是向HashMap添加一个Key为e(要添加的元素)，vlaue为定值(`private static final Object PRESENT = new Object();`)的键值对
  - value使用static final的好处是多个对象使用一份内存空间，减少内存消耗
  - 当添加一个元素时，首先会得到hashCode，用哈希值作为索引值查找table数组，如果此位置没有元素，则直接加入，否则调用equals比较，如果相同，就放弃添加否则加到链表后；如果一条链表的元素个数>=8，并且table的大小>=64时会进行树化(红黑树)
  - 因为底层是HashMap，所以源码关键在于HashMap，此处不展开过多

### 3. LinkedHashSet

- 为HashSet的子类
- 根据元素的hashCode来决定元素的存储位置，同时使用链表维护元素次序，使得元素看起来像是以插入顺序保存的
- 底层是一个LinkedHashMap(LinkedHashMap的底层为数组+双向链表)

## 5. Map

### 1. Map接口简介

- 常见实现类：HashMap、Hashtable和Properties
- Map用于保存具有映射关系的key-value键值对
- 没有实现同步，线程不安全
- key和value可以是任何引用类型和null，会被封装为Node类型
- key不允许重复(原因参见源码分析)，value可以重复；再次put同样的key为更新value值
- 只能通过key找到value而不能通过value找到key
- 为了方便遍历，底层会创建entrySet集合(`transient Set<Map.Entry<K,V>> entrySet;`)，该集合并没有存储数据，存储的只是指向key或value的指针
- entrySet集合实际存储的是Node类型
- EntrySet的entrySet只是一种封装，类似的还有KeySet类的keySet和Values的collection(三种类都是HashMap的内部类)

### 2. 常用方法

- put，remove
- get：根据键获取值
- size：获得元素个数
- isEmpty，clean
- containsKey：查找键是否存在

### 3. Map遍历

- 通过KeySet取出key，再通过key得到value

  ```java
  Set keySet=map.keySet();
          for (Object o : keySet) {
              System.out.println(map.get(o));
          }
  ```

- 使用迭代器

  ```java
  Iterator iterator=keySet.iterator();
          while (iterator.hasNext()){
              Object next=iterator.next();
              System.out.println(map.get(next));
          }
  ```

- 通过Values取出value

  ```java
  Collection values = map.values();
          for (Object value : values) {
              System.out.println(value);
          }
  ```

- 通过EntrySet取出entry

  ```java
  Set set = map.entrySet();
          for (Object o : set) {
              Map.Entry entry= (Map.Entry) o;
              System.out.println(entry.getValue());
          }
  ```

## 6. HashMap

### 1. HashMap简介

- 底层为数组+链表+红黑树(均为Node类型)
- 加载因子用于计算临界值，当size超过临界值时，就会扩容。临界值=加载因子(默认0.75)*最大值
- Node属性

```java
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
```

- HashMap的size为所有Node的数量，不是table中的已经使用的位置
- **hash()得出的hash不等同于hasCode**

### 2. 扩容和树化

- 第一次添加时，table数组扩容到16；如果size大于等于临界值12，就会扩容到16*2=32，新的临界值为24，再次扩容就是64，以此类推
- 默认情况下，一条链上的元素个数大于等于8**并且**table的大小大于等于64，就会进行树化，树化的对象是链表而不是整个HashMap
- TreeNode

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
        TreeNode<K,V> parent;  // red-black tree links
        TreeNode<K,V> left;
        TreeNode<K,V> right;
        TreeNode<K,V> prev;    // needed to unlink next upon deletion
        boolean red;
        TreeNode(int hash, K key, V val, Node<K,V> next) {
            super(hash, key, val, next);
        }
```

### 3. 源码分析

- 底层维护了一个Node数组table
- 执行put()前会执行hash()，该方法返回的并不是hashCode，而是右移16位后的异或

```java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

- put()会把hashKey和key、value丢入putVal方法，后者才真正执行put操作

```java
public V put(K key, V value) {
        return putVal(hash(key), key, value, false, true);
    }
```

- resize()会给予table默认大小(table为空时)或使其大小翻倍
- putVal()首先会定义一个Node数组tab，并定义变量n

```java
Node<K,V>[] tab;Node<K,V> p; int n, i;
if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
```

​		根据传进来的hash取计算key应该存放到table的哪个位置，并把这个位置的对象赋		值给p(p为索引位置链表的第一个Node)，如果p<font color="yellow">为空</font>，则创建一个Node放入需要存入的key-value(和hash)

```java
if ((p = tab[i = (n - 1) & hash]) == null)  //按位与不会超过原数，即索引不会大于数组长度
            tab[i] = newNode(hash, key, value, null);
```

​		如果<font color=yellow>不为空</font>：

```java
            Node<K,V> e; K k;   //先创建一个临时变量Node e
            if (p.hash == hash &&  //如果p的hash等于待添加Node的hash
                ((k = p.key) == key || (key != null && key.equals(k))))
                //前面判断是不是同一个对象(hashCode相同)，后面判断两个对象内容是否相同(equals==true)
                    e = p;
            else if (p instanceof TreeNode)  //再判断p是否为一棵红黑树
                    e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                                     //putTreeVal为红黑树的节点添加方法
            else {//不是同一个对象且内容不同且p不是红黑树
                    for (int binCount = 0; ; ++binCount) {  //遍历链表
                        if ((e = p.next) == null) {  //如果遍历完或链表只有p
                        p.next = newNode(hash, key, value, null);  //直接加p后面
                                if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                                    //TREEIFY_THRESHOLD为8，大于等于就要树化
                                    treeifyBin(tab, hash);  //转化成红黑树
                                break;//遍历完了break
                            }
                        if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                            //是否相同或相等，参见第4行注释
                            break;//找到相同break
                        p = e;  //向后移动一个(参见第11行e=p.next)
                    }//for在这里结束
            }//else在这里结束
    
            if (e != null) { // existing mapping for key
                //走else时e==null
                V oldValue = e.value;   
                if (!onlyIfAbsent || oldValue == null)  //oldValue==null再次判断
                    //onlyIfAbsent为真表示不更改现有值
                    e.value = value;  //更新值
                afterNodeAccess(e);  //留给子类拓展的方法
                return oldValue;  //把已经存在的Node(p)的值返回，表示失败
            }
```

​		加入完毕后检查是否超过临界值，是则resize()

​		最后留了一个空方法给子类拓展，返回null 
- 树化treeifyBin()

  如果tab.length<64，并不会树化，而是执行resize()扩容

### 4. LinkedHashMap

- 为HashMap的子类,底层为数组(HashMap.Node数组，但存放的是LinkedHashMap.Entry)+双向链表(Entry链表)

- 节点Entry属性

  ```java
  static class Entry<K,V> extends HashMap.Node<K,V> {
          Entry<K,V> before, after;
          Entry(int hash, K key, V value, Node<K,V> next) {
              super(hash, key, value, next); //调用父类HashMap.Node的构造函数
          }
  }
  ```


## 7. Hashtable

### 1. Hashtable简介

- key和value都不能为空

- 使用和HashMap基本一致

- 是线程安全的

- 底层也是数组+链表

- 与HashMap对比

  |           | 版本 | 线程同步 | 效率 | null值 |
  | :-------: | :--: | :------: | :--: | :----: |
  |  HashMap  | 1.2  |  不安全  |  高  |  允许  |
  | Hashtable | 1.0  |   安全   |  低  | 不允许 |

  

### 2. 源码分析

- 底层维护了一个数组(Hashtable$Entry类型)table，默认大小为11，加载因子0.75，临界值8

- Entry类型

  ```java
   private static class Entry<K,V> implements Map.Entry<K,V> {
          final int hash;
          final K key;
          V value;
          Entry<K,V> next;
  ```

- 扩容时新容量=旧容量*2+1

  ```java
  int newCapacity = (oldCapacity << 1) + 1;  //左移一位相当于*2
  ```

## 8. Properties

### 1. Properties简介

- 参见[4.3](#4.3)
- 继承自Hashtable并实现了Map接口
- 使用和Properties类似
- 可以用于从.properties配置文件中读取数据或把数据加载到配置文件中

## 9. TreeSet

### 1. TreeSet

- 实现了Set接口
- 输出有序(自然顺序)，或按照实现的Comparable接口排序，如果Object没有实现Comparable，则会报错
- 可以传入Comparator自定义排序
- 源码分析
  - 底层维护了一个TreeMap

### 2. TreeMap

- 实现了Map接口

- 默认key有序(自然顺序)，或按照实现的Comparable接口排序，如果Object没有实现Comparable，则会报错

- 

- 源码分析

  - 底层维护了一个红黑树

  - Entry属性

    ```java
        static final class Entry<K,V> implements Map.Entry<K,V> {
            K key;
            V value;
            Entry<K,V> left;
            Entry<K,V> right;
            Entry<K,V> parent;
            boolean color = BLACK;  //红黑树节点颜色
    ```

  - put时会遍历现有节点，不断调用compare，插入到适当位置

  - 如果compare方法比较结果是0(即按排序规则两者相等)，则不会添加，value会替换

## 10. Collections工具类

### 1. Collections工具类介绍

- 是一个操作Set、List和Map等集合的工具类
- Collections中提供了一系列静态的方法对集合进行排序、查询和修改等操作

### 2. 排序方法

- reverse(List)：反转List中元素的顺序
- shuffle(List)：对List集合元素进行排序
- sort(List)：根据元素的自然顺序对指定List集合元素按升序排序
- sort(List,Comparator)：根据Comparator指定的顺序对List进行排序
- swap(List,int i,int j)：交换索引为i和j的元素

### 3. 查找替换

- Object max(Collection)：根据自然顺序，返回最大值
- Object max(Collection,Comparator)：根据Comparator指定的顺寻，返回最大值
- Object max(Collection)，Object max(Collection,Comparator)：略
- int frequency(Collection,Object)：返回元素出现的次数
- void copy(List dest,List src)：把src的元素覆盖到dest中(覆盖意味着dest中相同索引值的元素会被替换为scr中的)，dest的size必须大于src的size
- boolean replaceAll(List list,Object oldVal,Object newVal)：使用新值替换list中所有旧值

## 11. 小结

### 1. 如何选择合适的集合类

1. 先判断存储的类型，选择单列集合(一组对象)或双列集合(一组键值对)
2. 一组对象：
   - 允许重复：List
     - 增删多：LinkedList(双向链表)
     - 改查多：ArrayList(Object类型数组)
   - 不允许重复：Set
     - 无序：HashSet(HashMap)
     - 排序：TreeSet
     - 顺寻：LinkedHashSet(LinkedHashMap)
3. 一组键值对
   - 键无序：HashMap(数组+链表+红黑树)
   - 键排序：TreeMap
   - 键顺序：LinkedHashMap(数组+双向链表)
   - 读写文件：Properties

# 8.HTML基础

## 1. HTML简介

### 1. W3C标准：

- 结构化标准语言：HTML、XML
- 表现标准语言：CSS
- 行为标准：DOM、ECMAScript

## 2. 常用标签

### 1. 基本标签

- h1~h6：标题标签
- p：段落标签
- br：单标签，换行标签
- hr：单标签，水平线标签
- strong或b：粗体
- em：斜体

### 2. img图像标签

- src：路径
- alt：加载失败提示字符
- title：鼠标悬停的提示文字

### 3. a链接标签

- href：链接路径
- target：目标窗口打开方式：blank(新标签)，self(当前标签)
- 可以用#跳转到当前页面标记处

### 4. 行内元素和块元素

- 行内元素：无论内容多少行，该元素独占一行
- 内容撑开宽度，左右都是行内元素的可以拍在一行

### 5. 列表

- ol和li：有序列表
- ul和li：无序列表
- 自定义列表：dl包裹，dt表头，dd表项

### 6. 表格

- table表格标签，tr行标签，td列标签
- colspan横向跨列，rowspan竖向跨行

### 7. 音视频标签

- video视频标签，audio音频标签
  - controls显示控制条
  - autoplay自动播放

### 8. 结构标签

- header头部，footer底部
- section区域，article文章
- aside侧边栏，nav导航栏

### 9. ifram内联框架

- frameborder框架边界

### 10. 表单

```html
<form method="post" action="result.html">
        <p>用户名：<input name="name" type="text"></p>
        <p>密码：<input name="pwd" type="password"></p>
        <br>
        <input type="submit" id="submit" value="登录">
        <input type="reset" id="reset" value="重填">
    </form>
```
- radio单选，checkbox多选
- select下拉框，option下拉选项
- textarea文本域
- placeholder输入框占位提示，required非空，pattern正则表达式
# 9. CSS3

## 1. CSS简介

- 层叠样式表Cascading Style Sheets

- 优点：内容和表现分离；网页结构表现统一，可以实现复用；样式丰富；利于SEO，容易被搜索引擎收录

- 语法

  ```css
  h1{//选择器+{}
              color: blue;//声明:属性;
          }
  ```

- 三种方式

  行内样式

  ```html
  <h1 style="color: blue;">测试CSS</h1>
  ```

  内部样式(style标签)

  ```html
  <style>
          h1 {
              color: blue;
          }
      </style>
  ```

  外部样式

  ```html
  /*  链接式，推荐*/
  <link rel="stylesheet" type="text/css" href="theme.css">
  /*  导入式，不推荐，会先加载页面，再渲染样式*/
  <style>
      @import url("css/style.css");
  </style>
  ```

  优先级：就近原则

## 2. 选择器

### 1. 基本选择器：

- 标签选择器
- 类选择器：可以复用，只需要使用相同的id即可
- id选择器：id一般不可重复
- 优先级：id>类>标签

### 2. 层次选择器：

- 后代选择器：在某个元素后面

  ```css
  h1 p {/*h1后面的所有p标签应用*/
              color: #9dff00;
          }
  ```

- 子选择器

  ```css
   h1>p {/*h1后面的一代p标签应用*/
              color: #460f35;
          }
  ```

- 相邻兄弟选择器

  ```css
  .myh1+h1 {/*class=".myh1"的下一个标签为h1时，给h1应用*/
              color: #da199c;
          }
  ```

### 3. 结构伪类选择器

- 选择标签的一定规则的

  ```css
  ul li:first-child{  /*ul里第一个子类且为li时，给li应用*/
              color: brown;
          }
  ```

### 4. 属性选择器

- 标签名属性名=属性值(属性值可以不要，也可以使用正则)

  ```css
  a[id=first]{  /*选中a标签中属性等于first的*/
              background-color: cadetblue;
          }
  
  /*
  = 绝对等于
  *=包含
  */
  ```

## 3. 美化页面元素

### 1. 字体文本

- span标签
- 超链接伪类

### 2. 列表

### 3. 背景

### 4. 盒子模型

# 10. JavaScript

## 1. JavaScript简介

### 1. 标准

- ES5：过时
- ES6：常用

### 2. 框架

- jQuery(库)：简化了DOM，影响性能
- Angular：Google和Microsoft合作，模块化，TypeScripet语法，后端友好前端不友好
- React：Facebook出品，虚拟DOM提升效率，需要额外学习JSX
- Vue：渐进式，综合了模块化和虚拟DOM
- Axios：前端通信框架

### 3. UI框架

- Ant-Design：阿里巴巴出品，基于React
- ElementUI：饿了么出品，基于Vue
- Bootstrap：Twitter出品，前端工具包
- AmazeUI

### 4. 构建工具

- Babel
- WebPack

## 2. 快速入门

### 1. 引入

- 内部模式

  ```html
  <script>
      alert('helloworld')
      </script>
  ```

- 外部引入

  ```html
  <script src="js/1.js">
      </script>
  ```

- 注：&lt;script>标签必须成对出现

### 2. 基本语法

- console.log(num)

- 数据类型：基本类型(字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol)和引用类型(对象(Object)、数组(Array)、函数(Function))

  - number：不区分整数浮点数等
  - 字符串：单引号和双引号皆可
  - 数组：使用[]和逗号
  - 布尔
  - null：空
  - nuderfined：未定义
  - Symbol：ES6引入，表示独一无二的值

- 逻辑运算

- 比较运算符

  - ==：等于，只检查值，类型不同值相同也会返回true
  - ===：绝对等于，检查类型和值
  - NaN不绝对等于任何数，包括自己，只能通过isNaN判断是否为NaN

- 对象：使用{}和逗号

  ```javascript
  var person={
      name:"张三",
      age:18,
      tags:['js','py','java']
  }
  
  console.log(person.age)//打印结果：18
  ```

- 严格检查模式：`'use strict'` 必须写在第一行

### 3. 数据类型

- 字符串：

  - 转义字符：\

  - \u4e2d：Unicode字符

  - \x41：Ascii字符

  - 多行字符串

    ```javascript
    let msg=
                `hello
                world
                ni
                hao`
    ```

  - 模板字符串

    ```javascript
    let msg='HelloWorld'
            let msg2=`你好鸭,${msg}`
    ```

  - 字符串不可变

- 数组

  - 可以包含任意数据类型
  - 数组长度可变(通过给array.length赋值)
  - slice()：截取一部分返回一个新的数组，类似String的substring
  - push()：加到数组最后，pop()：删掉数组最后
  - unshift()：加到数组头部，shift：删掉数组头部
  - sort()：排序(自然顺序)
  - reserve()：元素反转
  - concat()：拼接到尾部(没有修改原来的数组)
  - join()：使用特定的链接符打印数组
  - 多维数组
  
- 对象

  - 若干个键值对组成

    ```javascript
    var person={
        name:"张三", //属性名:属性值,
        age:18,
        tags:['js','py','java'] //最后一项不需要逗号
    }
    ```

  - js中所有的键都是字符串类型

  - 使用一个不存在的对象属性，报undefined

  - 动态增删属性：通过delete删除对象属性，通过赋值添加对象属性

  - 通过in可以判断属性是否在类中(包括父类中)，hasOwnProperty()判断是否自身拥有(不包括父类)

### 4. 流程控制

- if else

- while

- for

  ```javascript
  var num=[1,2,3,4,5,6,7,8];
          for (let number of num) {   //for of 遍历的是元素值
              console.log(number)  //输出12345678
          }
  
  for (let number in num) { //for in 遍历的是索引
              console.log(number)  //输出01234567
          }
  
   num.forEach(function (value) {  //forEach   类似Lambda
              console.log(value)  //输出12345678
          })
  ```

### 5. 数据结构

- Map

  ```javascript
  var map=new Map([["tom",100],["jack",90],["alice",95]]);
          let name=map.get("jack")
          console.log(name)
          for (let mapElement of map) { //mapElement是一个数组
              console.log(mapElement)
          }
  ```

- Set

  ```javascript
  var set=new Set([1,2,3,4,5,6,1,1]);  //Set可以去重
  ```

## 3. 函数

### 1. 函数定义

```javascript
function abs(x) {  //方式一
            if (x >= 0) {
                return x;
            } else {
                return -x;
            }
        }

var adb=function (x){  //方式二，此方式函数为匿名，变量存储的是函数表达式
            return x*x; 
        }

adb(9);  //调用变量存储的函数表达式并返回
```

- 如果没有return或没有执行return，则会reutrn undefined

- 函数可以传任意个参数，包括不传,传进来的所有参数都存在，在arguments中(arguments像数组但不是数组，是个对象)

- 可变参数

  ```javascript
  var adb=function (a,b,...c){  //除前两个参数外其他的都会被装入数组c
              return a*b;
          }
  ```

### 2. 变量作用域

- 内部变量会覆盖外部的

- 默认所有的全局对象都会绑定在window上

- var：

  - 如果在函数体内声明，则作用域为函数体，否则为文件作用域
  - var会自动提升变量的声明，但不会提升赋值(会报NaN或undefined)

- let：块作用域，建议使用let

  ```javascript
  for (var i = 0; i <10 ; i++) {  //如果改为let则11无法输出
              console.log(i);
          }//输出0~9
          console.log(i+1); //输出11  
  ```

- const：ES6特性，表示常量，特性和let完全一致，**除了定义时一定要赋值**


### 3. 方法的定义和调用

- 方法就是把函数放在对象的内部；对象内只有两种东西：属性和方法

- 调用方法记得带小括号

  ```javascript
  let person={
              name:'张三',
              birth:2000,
              //方法
              age:function (){
                  let now=new Date().getFullYear();
                  return now-this.birth;
              }
          }
  
  person.age()   //22
  ```

  ```javascript
  function getAge (){
              let now=new Date().getFullYear();
              return now-this.birth;  //this指向调用它的对象
          }
  
          let person={
              name:'张三',
              birth:2000,
              //方法
              age:getAge  //这样写也可以
          }
  ```

- js中可以控制this的指向

  ```javascript
  getAge.apply(person,[]);//让getAge的this指向person，参数为空
  ```

### 4. 内部对象

- typeof：返回类型
- Date

### 5. JSON

- json是轻量级数据交换格式

- 格式：对象和map用{}，数组用[]，所有的键值对都用key:value

- 序列化与反序列化

  ```javascript
  JSON.stringify(user)  //序列化
  JSON.parse(json)  //反序列化
  ```

- Ajax：

  - 原生js写法：xhr异步请求
  - jQuery封装好的：$("#name").ajax("")
  - axios请求

## 4. 面向对象

### 1. 什么是面向对象

- 类：模板
- 对象：实例

### 2. Javascript的面向对象

在Javascript中概念不一样：

- 原型：相当于父类

  ```javascript
  lisi.__proto__=user  //lisi的原型为user，即lisi继承于user
  
  
  function Student(name) {
      this.name=name;
  }
  
  Student.prototype.hello=function () {  //用原型给Student加一个方法
      console.log("hello")
  }
  ```

- class：ES6引入的关键字

  ```javascript
  class Student {
      constructor(name) {
          this.name = name
      }
      hello(){
          console.log('hello')
      }
  }
  class pupil extends Student{  //继承
      constructor(name,grade) {
          super(name)
          this.grade=grade
      }
      myGrade(){
          console.log("我是小学生"+this.name)
      }
  }
  
  let jack=new Student("jack")
  let tom=new pupil("tom",3)
  jack.hello()
  tom.hello()
  tom.myGrade()
  ```

## 5. DOM对象

### 1. 常见BOM对象

- Browser Object Model ，浏览器对象模型
- window：代表浏览器窗口
- navigator：封装了浏览器的信息，大多数时候不会用navigator对象，因为会被修改
- screen：屏幕尺寸
- location：当前页面的url
- document：即DOM，当前页面
- history：历史(不建议使用)

### 2. DOM对象

- 浏览器网页就是一个DOM树形结构

- DOM对象主要有四个操作：添加，删除，更改，遍历

- 要操作一个DOM节点，必须先获得这个节点

  ```javascript
  document.getElementById('id1')
  document.getElementByTagName('h1')  //返回的是数组
  document.getElementByClassName('p2')
  p2.children  //获得父节点下所有子节点
  ```

### 3. DOM操作节点

- 更新节点

  ```javascript
  id1.style.color='red'
  id1.innerText='12334'
  ```

- 删除节点

  ```javascript
  id1.remove()  //删除自身
  father.removeChild('p1')  //通过父节点删除
  ```

- 插入节点：

  - 得到DOM节点后，可以通过innerHTML增加元素，如果节点存在元素，则会覆盖

    ```html
    <p id="js">JavaScript</p>
    <div id="java">
        <p id="se">JavaSE</p>
        <p id="ee">JavaEE</p>
        <p id="me">JavaME</p>
    </div>
    
    <script>
        let js = document.getElementById("js")
        let java = document.getElementById("java")
        let newP = document.createElement('p')  //创建一个p标签
        newP.id = 'newP'  //等价于newP.setAttribute('id','newP')
        newP.innerText = 'helloWorld'    
        java.appendChild(newP)  //把p标签插入到最后
        java.insertBefore(newP,ee)  //把p标签插入到ee前
    
        let myjs = document.createElement('script')
        myjs.setAttribute('type','text/javascript')
    </script>
    ```

### 4. 操作表单

- 获取并修改表单数据

  ```javascript
  <form action="post">
      <span>用户名：</span><input type="text" id="username">
  </form>
  
  <script>
      let name=document.getElementById("username")
      name.value  //返回值
      name.value=123  //给输入框赋值
  </script>
  ```

- 提交加密

  ```html
  <head>
      <meta charset="UTF-8">
      <title>Form</title>
      //引入第三方库
      <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  </head>
  <body>
  
  <form action="post" method="post">
      <span>用户名：</span><input type="text" id="username" name="username" required>
      <br>
      <span>密码：</span><input type="password" id="password" name="password">
      <button type="submit" onclick="f()">登录</button>
  </form>
  
  <script>
      let name=document.getElementById("username")
      let pwd=document.getElementById("password")
  
      function f(){
          pwd.value=md5(pwd.value)  //MD5加密
          console.log("用户名："+name.value)
          console.log("密码："+pwd.value)
      }
  </script>
  
  </body>
  ```

## 6. jQuery

### 1. jQuery简介

- 一个js库，[文档](https://jquery.cuishifeng.cn/)

- 引入：可以下载，可以CDN引入

- 模板：$(selector).action    selector为CSS的选择器

  ```html
  <a href="" id="testJQ">点我</a>
  
  <script>
      $('#testJQ').click(function (){
          alert("点你")
      })
  </script>
  ```

### 2. jQuery选择器

- 原生js选择器：标签，id，类
- jQuery选择器：
  - 标签：$('p').click()
  - id：$('#id1').click()
  - class：$('.class1').click()

### 3. 事件

- 鼠标事件，键盘事件，其他事件

  ```html
  <body>
  
  mouse：<span id="mouseMove"></span>
  <div id="div" style="width: 500px;height: 500px;border: 1px solid red">
      在这里移动鼠标试试
  </div>
  
  <script>
      //当网页元素加载完毕后，相应事件
      $(function () {
          $('#div').mousemove(function (e){  //鼠标移动事件
              $('#mouseMove').text('x：'+e.pageX+' y：'+e.pageY)  //获取值
          })
      })
  </script>
  
  </body>
  ```

### 4. jQueryDOM

- 获取和修改值

  ```html
  <ul id="test_ul">
      <li class="js">JavaScript</li>
      <li id="py">Python</li>
  </ul>
  
  <script>
      $('#test_ul li[id="py"]').text();  //返回值
      $('#test_ul li[id="py"]').text('Pythoooo');   //设置值为Pythoooo
      $('#test_ul').html();  //返回html代码
      $('#test_ul').html('\n    <li class="js">JavaScript</li>\n    <li id="py">Python3.888888</li>\n')   //设置html代码
  </script>
  ```

- 修改CSS

  ```javascript
  $('#test_ul li[class=js]' ).css('color','red')  //修改颜色
  $('#test_ul li[class=js]' ).hide()  //隐藏
  ```

# 11. MySQL

## 1. SQL简介

### 1. 数据库

- 数据库是所有软件体系中最核心的存在
- 关系型数据库和非关系型
- DBMS

### 2. 命令行操作MySQL

```sql
net start mysql80  
net stop mysql80 --windows启动和停止MySQL服务器

mysql -uroot -p  --输入密码后即可登录

show databases;  --查看所有数据库，不要忘记分号
use school;  --切换数据库为school
show tables;  --查看数据库中所有表
describe student  --查看student表结构

create database aaa  --创建数据库aaa
exit;  --退出
```

## 2. 操作数据库

### 1. 操作数据库

```sql
create database [if not exists] aaa --创建数据库
drop database [if exists] aaa --删除数据库
-- 用``包裹可以把sql保留字变成表名(或其他名)
use aaa --切换到aaa
```

### 2. 字段属性

- 数值类型

  ```sql
  tinyint  --极小数的数据类型  1字节
  smallint  --较小数据   2字节
  mediumint  -- 3字节
  int   --4字节
  bigint --8字节
  float --浮点数
  double  --双字节浮点数
  decimal  --字符串浮点数，金融行业用，保证精度
  ```

- 字符串类型

  ```sql
  char  --固定大小字符串 0~255 单位为字符
  varchar  --可变字符串 0~65535  单位为字符
  tinytext --微型文本  2^8-1
  text  --文本  2^16-1
  ```

- 时间日期

  ```sql
  date  --YYYY-MM-DD
  time  --HH:mm:ss
  datetime --上面两个加起来
  timestamp  --时间戳
  year  --年份
  ```

- 其他

  ```sql
  Unsigned --无符号整数，该行不能为负数
  zerofill --不足的用0填充
  auto_increment  --自增，默认加一
  not null --非空
  default  --不填时的默认值
  ```

- 扩展：每个表最好都有以下字段

  ```sql
  id   --主键
  `version`  --乐观锁
  is_delete   --伪删除
  gmt_create  --创建时间
  gmt_updata  --修改时间
  ```

### 3. 操作表

 ```sql
  create table [if not exists] `student`(  --新建表
  `id` int(4) not null auto_increment comment '注释', 
      --每句语句结束都要,  括号最后一句不用
      `name` varchar(30) not null default '123456'
      primary key(`id`)
  )engine=innodb default charset=utf8
  
  alter table student as student1 --修改表名
  alter table student age int(11)  --增加字段
  alter table student modify age varchar(11)  --修改字段属性
  alter table student change age age1 int(1) --修改字段属性(同时重命名)
  alter table student drop age1  --删除字段
  drop table student  --删除表
 ```

### 4. 数据库引擎

|            |    myisam    |    innodb     |
| :--------: | :----------: | :-----------: |
|  事务支持  |    不支持    |     支持      |
| 数据行锁定 | 不支持(表锁) |     支持      |
|  外键约束  |    不支持    |     支持      |
|  全文索引  |     支持     |    不支持     |
| 表空间大小 |     较小     | 较大(约为2倍) |

- myisam：节约空间，速度较快
- innodb：安全性高，事务，多表多用户操作
- 数据库文件存储在data目录下，一个数据库一个文件夹，不同引擎文件不同
  - innodb：在表文件夹中只有一个.frm文件，以及上级目录的ibdata文件
  - myisam：在表文件夹中有三个文件(.frm表结构文件，.myd数据文件，.myi索引文件)

### 5. 外键

- 生产环境尽量不用数据库级外键(物理外键)，外键应在程序中实现

### 6. 操作数据

```sql
insert into   --插入
update  --修改，记得带where
delete  --删除，记得带where，否则准备跑路
truncate  --完全清空一个数据库表，表结构和索引不会变
```

- delete和truncate都能删除数据而不影响表结构
  - truncate能重新设置自增列(即计数器会归零)且不影响事务
  - delete删除后，重启数据库，innodb自增会从1开始(存在内存中)，myisam会继续上一个自增量(存在硬盘中)

### 7. 查询

- DQL：数据查询语言

- ```sql
  select
  select 100*3-1 as 计算结果  --select也可以用来计算，as后是别名
  distinct --去重
  ```

- where条件子句

- 模糊查询

  |   运算符    |       语法        |          描述           |
  | :---------: | :---------------: | :---------------------: |
  |   is null   |     a is null     |      a为空，返回真      |
  | is not null |   a is not null   |      a为空，返回假      |
  | between and | a between b and c |   a在b和c之间，返回真   |
  |    like     |     a like b      | sql匹配，a匹配b，返回真 |
  |     in      |   a in (1,2,3)    |    a在集合中，返回真    |

- 联表查询：7种join on

- 排序：order by

- 分页：limit，必须放在所有语句最后

- 函数和聚集函数

### 8. 数据库级MD5加密

- MD5

- ```sql
  update testmd5 set pwd=md5(pwd)   --md5为内置md5函数
  ```

## 3. 事务

### 1. 事务简介

- acid：
  - 原子性(Atomicity)：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生
  - 一致性(Consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态
  - 隔离性(Isolation)：事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离
  - 持久性(Durability)：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响
- 常见问题：
  - 脏读：读取了另一个事务为提交的数据
  - 不可重复读：在一个事务内读取表中某一行数据，多次读取结果不同
  - 幻读：读取到了另一个事务插入的数据，导致前后读取不一致

### 2. 事务

- mysql默认开启事务提交

- ```sql
  set autocommit = 0 --事务开始前关闭自动提交
  start transaction  --标记一个事务的开始
  commit  --提交
  rollback  --回滚
  set autocommit = 1  --事务结束开启自动提交
  
  savepoint  aaa  --存档点
  rollback to savepoint  aaa   --回滚到存档点
  ```

## 4. 索引

### 1. 索引简介

- 索引是帮助MySQL高效获取数据的数据结构

### 2. 索引分类

- 主键索引(primary key)：唯一标识，不可重复，只能有一个(但可以为多列)
- 唯一索引(unique key)：避免重复列出现
- 常规索引(key / index)：默认的
- 全文索引(fulltext)：快速定位数据

### 3. 索引的使用

- ```sql
  show index form student  --显示所有的索引信息
  alter table `student` add fulltext index `studentName` (`studentName`)  --添加索引
  -- 索引名(列名)
  explain  --分析sql执行的状况(模拟sql优化器执行sql)
  ```


### 4. 索引原则

- 索引不是越多越好
- 不要对经常变动的数据加索引
- 小数据量的表不需要索引
- 索引一般加在常用来查询的字段上
- 参见：[索引的本质](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

## 5. 管理

### 1. 用户管理

- 略

### 2. 备份

- 直接拷贝硬盘文件
- 在可视化工具中手动导出
- 用命令行导出

## 6. 数据库设计

### 1. 数据库设计对比

|          设计糟糕          |    设计良好    |
| :------------------------: | :------------: |
|     数据冗余，浪费空间     |    节约空间    |
| 数据插入删除麻烦，易报异常 | 保证数据完整性 |
|           性能差           |    性能优秀    |

### 2. 三大范式

- 参见GoodNotes笔记
- 生产环境不一定会完全遵循范式(如故意增加冗余列、计数列)

### 3. 设计数据库的步骤

- 分析需求：分析业务和需要处理的数据库的需求
  - 列出需要的表
  - 标识实体：把需求落地到每个字段
  - 表示试题间的关系
- 概要设计：设计关系图、E-R图

## 7. <span id="11.7">JDBC</span>

### 1. 数据库驱动

- 不同数据库有不同的驱动
- SUN公司为简化数据库操作，提供了一个Java规范，简称JDBC(Java Database Connectivity)

### 2. 连接步骤

```java
//1.加载驱动
        Class.forName("com.mysql.cj.jdbc.Driver");
        //2. 定义用户信息和url
        String url="jdbc:mysql://localhost:3306/school?characterEncoding=utf8&useSSL=true&serverTimezone=UTC&rewriteBatchedStatements=true";
        String username="root";
        String pwd="MySQL80";
        //3. 开始连接，获得数据库对象
        Connection connection= DriverManager.getConnection(url,username,pwd);
        //4. 创建statement对象
        Statement statement = connection.createStatement();
        //5. 执行sql，获得结果
        String sql="select * from student";
        ResultSet resultSet = statement.executeQuery(sql);
        while (resultSet.next()){  //输出结果
            System.out.println("id= "+resultSet.getObject("id"));
            System.out.println("name= "+resultSet.getObject("name"));
            System.out.println("age= "+resultSet.getObject("age"));
        }
        //6. 释放连接
        resultSet.close();
        statement.close();
        connection.close();
```

### 3. JDBC备注

- Connection connection为数据库对象

- statement.executeQuery()：执行查询sql，返回ResultSet

- statement.execute()：执行任何sql语句

- statement.executeUpdate()：执行除查询以外的sql，返回受影响的行数

- 获得指定数据类型

  ```java
  resultSet.getObject();
  resultSet.getInt();
  resultSet.getString();
  resultSet.getFloat();
  resultSet.getDouble();
  ```

- 遍历

  ```java
  resultSet.beforeFirst();  //移动到最前
  resultSet.afterLast();  //移动到最后
  resultSet.next();  //移动到下一个数据
  resultSet.previous();  //移动到前一个
  resultSet.absolute();  //移动到指定行
  ```

### 4. JDBC事务

- ```java
  connection.setAutoCommit(false);//关闭自动提交，开启事务
  String sql = "";
  statement = connection.prepareStatement(sql);
  statement.executeUpdate();
  connection.rollback();//失败则回滚
  ```

- 

## 8. SQL注入

### 1. SQL注入

- sql存在漏洞，会被攻击导致数据泄露

### 2. PreparedStatement对象

- 可以防止SQL注入，效率更高

- ```java
  String sql="insert into student(id,`name`,`password`) values(?,?,?)";
              statement=connection.prepareCall(sql);//预编译SQL，不执行
              statement.setInt(1,4);
              statement.setString(2,"zhangsan");
              statement.setString(3,"pass123456");//赋值
  ```

- 本质，把参数当作字符，并把`直接转义

## 9. 数据库连接池

### 1. 池化技术

- 参见[6.10.1](#6.10.1)
- 编写连接池，需实现一个接口DataSource
- 常见开源连接池：DBCP、C3P0、Druid

# 12. JavaWeb

## 1. 基本概念

### 1. JavaWeb

- 在Java中，动态web开发的技术统称JavaWeb
- 一个Web应用由多部分组成：
  - html，css，js
  - jsp，servlet
  - java程序
  - jar包
  - 配置文件(Properties)

### 2. web服务器技术

- ASP：
  - 微软开发
  - 在HTML中嵌入了VB脚本(ASP+COM)
  - 代码极长，维护性成本高
- PHP：
  - 开发速度块，功能强大，跨平台，代码简单
  - 无法承载大访问量情况
- JSP/Servlet：
  - SUN公司主推的B/S架构
  - 基于Java
  - 可以处理三高(高并发，高可用，高性能)问题
  - 语法类似ASP

### 3. Web服务器

- IIS：Internet Information Services(互联网信息服务)Windows内置
- TomCat：Apache基金会核心项目

### 4. TomCat

### 5. HTTP

- post和get

  |                            get                            |           post           |
  | :-------------------------------------------------------: | :----------------------: |
  |                   浏览器回退时是无害的                    |      会再次提交请求      |
  | 把参数包含在URL中(所以可以添加书签，在历史记录里也会保留) | 通过request body传递参数 |
  |                    会被浏览器主动cache                    |         默认不会         |
  |             只能进行url编码，只接受ASCII字符              |         多种编码         |
  |                       参数长度有限                        |            无            |
  |                     不安全(url会暴露)                     |            无            |

  

- post和get拓展：post和get都是HTTP 协议中的两种发送请求的方法，HTTP 的底层是 TCP/IP。所以 get和 post 的底层也是 TCP/IP，也就是说，get/post 都是 TCP 链接，get 和 post 能做的事情是一样一样的(当然其他请求也一样)，要给 get 加上 request body，给 post 带上 url 参数，技术上是完全行的通的。因此以上 区别和各种method也只是订个标准方便区分

  例：（大多数）浏览器通常都会限制 url 长度在 2K 个字节，而（大多数）服务器最多处理 64K 大小的 url。超过的部分，恕不处理。如果用 get 请求，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你读出数据，有些服务器直接忽略。所以，虽然 get 可以带 request body，但不能保证一定能被接收到

- get产生一个 TCP 数据包；post 产生两个 TCP 数据包：

  对于 get 方式的请求，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）

  而对于 POST，浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 ok（返回数据）

  注意：并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次；在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点

- 最好不要只用一个完全不用另一个，get 与 post 都有自己的语义，不能随便混用，参见[博客园](https://www.cnblogs.com/logsharing/p/8448446.html)

### 6. Maven

- 约定大于配置

## 2. Servlet

### 1. Servlet简介

- Servlet是SUN公司开发的实现动态web的技术
- SUN在这些API中提供了一个接口：Servlet，实现Servlet接口的Java程序叫Servlet
- SUN提供了两个默认的实现类：HttpServlet，GenericServlet(HttpServlet继承GenericServlet实现Servlet)

### 2. HelloServlet

- java代码

  ```java
  @WebServlet(name = "hello",urlPatterns = "/hello")
  //如果加注解，就不用xml
  public class HelloServlet extends HttpServlet {
      @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          PrintWriter writer=resp.getWriter();
          writer.println("helloWorldServlet");
      }
  
      @Override
      protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          doGet(req, resp);
      }
  }
  ```

- web.xml

  ```xml
  <servlet>
          <servlet-name>hello</servlet-name>
          <servlet-class>nnk.pininkara.servlet.HelloServlet</servlet-class>
  </servlet>
  <servlet-mapping>
          <servlet-name>hello</servlet-name>
          <url-pattern>/hello</url-pattern>  <!--记得加 '/' -->
  </servlet-mapping>
  ```

### 3. Servlet原理

- request会从service拿到请求并且把请求之后的相应交给response
- 编写实现类应重写*接收并处理请求的方法*和*给出相应信息的方法*

### 4. mapping

- 一个Servlet可以指定多个映射路径

- 映射路径也可以直接用/* 会覆盖首页(index)

- 可以自定义后缀

  ```xml
  <servlet-mapping>
          <servlet-name>hello</servlet-name>
          <url-pattern>*.servlet</url-pattern>  <!--不可以加路径-->
      </servlet-mapping>
  ```

- 精准匹配比通配符优先级高

### 5. ServletContext

- 可以在web.xml里配置默认参数

  ```xml
  <servlet>
          <servlet-name>error</servlet-name>
          <servlet-class>nnk.pininkara.servlet.ErrorServlet</servlet-class>
          <init-param>
              <param-name>namespace</param-name>  <!--参数名-->
              <param-value>123</param-value>  <!--参数值-->
          </init-param>
      </servlet>
  ```

- web容器在启动时，会每个web程序都创建一个web对象，它代表当前的web应用

- ServletContext用于保存数据，所有Servlet均可访问；避免使用，应用session

  ```java
  ServletContext context=this.getServletContext();
  context.setAttribute("username",username);  //写入数据
  
  String username = (String) context.getAttribute("username");  //取出数据
  ```

- ServletContext的参数也可以在web.xml里配置，此方式一般用于数据库连接等初始化需要的参数

  ```xml
  <context-param>
          <param-name>namespace</param-name>
          <param-value>123</param-value>
  </context-param>
  ```

  ```java
  ServletContext context=this.getServletContext();
  context.getInitParameter();   //获取初始化参数
  ```

- 请求转发

  ```java
  //转发到/hello路径
  RequestDispatcher requestDispatcher = context.getRequestDispatcher("/hello");
  requestDispatcher.forward(req,resp);  //调用forward
  ```

- 转发和重定向的区别

  |              |                           转发                           |                            重定向                            |
  | :----------: | :------------------------------------------------------: | :----------------------------------------------------------: |
  |   请求次数   | 服务器收到请求后为了完成响应跳转到一个新的地址，请求一次 | 浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，至少请求两次 |
  |    地址栏    |                    地址栏不会发生变化                    |                       地址栏会发生变化                       |
  | 是否共享数据 |                  转发一次请求共享数据*                   |                      两次请求不共享数据                      |
  |   跳转限制   |                    只能跳转本站点资源                    |                      可以跳转到任意URL                       |
  |   行为不同   |                       服务器端行为                       |                          客户端行为                          |

  *：在request级别使用信息共享，使用重定向必然出错

### 6. Response

- web服务器收到客户端的请求会分别创建一个HttpServiceRequest对象和一个HttpServiceResponse对象

- 设置响应体

- 文件下载实例

  ```java
  //1.获取下载文件的路径
  String path = "E:\\Picture\\art.png";
  //2.下载文件的文件名
  String name = path.substring(path.indexOf("\\") + 1);
  //3.让浏览器支持下载
  resp.setHeader("Content-Disposition", "attachment;filename=" + name);
  //4.获取下载文件的输入流
  FileInputStream fileInputStream = new FileInputStream(path);
  //5.创建缓冲区
  int len;
  byte[] buffer = new byte[1024];
  //6.获取OutputStream对象
  ServletOutputStream out = resp.getOutputStream();
  //7.将FileOutputStream流写入buffer缓冲区
  while ((len = fileInputStream.read(buffer)) > 0) {
      out.write(buffer, 0, len);
  }
  //8.关闭流
  fileInputStream.close();
  out.close();
  ```

- 验证码实例

  ```java
  //让浏览器5秒刷新一次
  resp.setHeader("refresh","5");
  //在内存中创建一个图片
  BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
  //得到图片
  Graphics2D graphics2D = (Graphics2D) image.getGraphics();//画笔
  //设置图片的背景颜色
  graphics2D.setColor(Color.white);
  graphics2D.fillRect(0,0,80,20);
  //给图片写数据
  graphics2D.setColor(Color.blue);
  graphics2D.setFont(new Font(null,Font.BOLD,20));
  graphics2D.drawString(makeRan(),0,20);
  //告诉浏览器，这个请求用图片的方式打开
  resp.setContentType("image/jpeg");
  //让浏览器不缓存
  resp.setDateHeader("expires",-1);
  resp.setHeader("Cache-Control","no-cache");
  resp.setHeader("Pragma","no-cache");
  //把图片写给浏览器
  boolean write = ImageIO.write(image, "jpg", resp.getOutputStream());
  ```

- 重定向实例

  ```java
  resp.sendRedirect("/servlet01_war/image");
          /* 相当于做了这两步
          resp.setHeader("Location","/servlet01_war/image");  
          resp.setStatus(302);
          */
  ```


### 7. Request

- 登录实例

  ```jsp
  <form action="${pageContext.request.contextPath}/test" method="get">
      用户名：<input type="text" name="username"><br>
      密码：<input type="password" name="password"><br>
      <input type="submit">
  </form>
  ```
  `${pageContext.request.contextPath}`表示当前项目
  
  ```java
  @Override
      protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
          System.out.println("进入请求捏");
          String username=req.getParameter("username");
          String password = req.getParameter("password");
          System.out.println("username: "+username);
          System.out.println("password: "+password);
          resp.sendRedirect("/servlet01_war/success.jsp");
      }
  ```
  
- 请求转发

  ```java
  //请求转发，注意不要加项目名
  req.getRequestDispatcher("/success.jsp").forward(req,resp);
  ```

## 3. Cookie和Session

### 1. 会话

- 有状态会话和无状态会话

### 2. Cookie

- 一个简单的Cookie实例
  ```java
  PrintWriter out= resp.getWriter();  //页面的对象
  
          Cookie[] cookies=req.getCookies();  //获得cookie
          if (cookies != null) {
              out.write("上次访问时间为: ");
              for (Cookie cookie : cookies) {
                  if (cookie.getName().equals("time")){  //获得cookie指定内容
                      long lastTime =Long.parseLong(cookie.getValue());
                      Date date=new Date(lastTime);
                      out.write(date.toLocaleString());
                  }
              }
          }else {
              out.println("第一次来捏");
          }
          //设置cookie，如果不是第一次就是更新cookie
          Cookie cookie=new Cookie("time",System.currentTimeMillis()+"");  
          cookie.setMaxAge(24*60*60);
          resp.addCookie(cookie);
  
  ```

- 一个Cookie只能保存一个信息，一个web站点最多存放20个Cookie，一个浏览器最多保存300个Cookie，一个Cookie最大4kb

- Cookie的maxAge决定着Cookie的有效期，单位为秒。正数为有效期，负数表示该Cookie仅在本浏览器窗口以及本窗口打开的子窗口内有效，关闭窗口后该Cookie即失效，0表示删除该Cookie（因为Cookie机制没有提供删除Cookie的方法，因此通过设置该Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除）

### 3. Session

- 服务器会给每个用户（浏览器）创建一个Session

- 一个简单的Session实例

  ```java
  HttpSession session=req.getSession();//获得Session
  session.setAttribute("name","nnk");//在Session中存东西
  String id =session.getId();  //获得SessionID
  if (session.isNew()){
          resp.getWriter().write("Session创建成功，ID为："+id);
  }else {
          resp.getWriter().write("Session已经创建，ID为："+id);
          }
  String name = (String) session.getAttribute("name");
  System.out.println(name);
  ```

- web.xml的配置

  ```java
  <!--Session配置-->
  <session-config>
          <session-timeout>15</session-timeout> <!--单位为分钟-->
  </session-config>
  ```


### 4. Cookie和Session的区别

- [参见](https://www.cnblogs.com/l199616j/p/11195667.html)

## 4. JSP

### 1. JSP简介

- JSP：Java Server Pages
- 原理：jsp会被转化为已给java类（java代码会原样输出，html代码会通过out输出），所以jsp本质是一个Servlet
- 常见内置对象

  ```java
  final javax.servlet.jsp.PageContext pageContext;  //页面上下文
  javax.servlet.http.HttpSession session = null;        //session
  final javax.servlet.ServletContext application;      //application
  final javax.servlet.ServletConfig config;                   //config
  javax.servlet.jsp.JspWriter out = null;                       //out
  final java.lang.Object page = this;                               //page 当前页
  javax.servlet.jsp.JspWriter _jspx_out = null;
  javax.servlet.jsp.PageContext _jspx_page_context = null;
  ```

- 输出页面前的增加的代码

  ```java
  response.setContentType("text/html; charset=UTF-8");
        pageContext = _jspxFactory.getPageContext(this, request, response,
        			null, true, 8192, true);
        _jspx_page_context = pageContext;
        application = pageContext.getServletContext();
        config = pageContext.getServletConfig();
        session = pageContext.getSession();
        out = pageContext.getOut();
        _jspx_out = out;
  ```


### 2. JSP基础语法

- java语法都支持，除此之外JSP还有自己的额外语法

- 几句简单的jsp

  ```jsp
  <%--一般的jsp--%>
  <%   
      int sum = 0;
      for (int i = 1; i <= 100; i++) {
          sum += i;
      }
      out.println("<h1>Sum=" + sum + "</h1>");
  %>
  
  ${sum}   <%--EL表达式--%>
  
  <%--  =的jsp，用于变量或表达式--%>
  <% =new java.util.Date() %>
  
  <%--  jsp声明 --%>
  <%!
  static {
      System.out.println("Loading Servlet!");
  }
  %>
  ```

- jsp的注释无法在客户端显示，html注释会

### 3. JSP指令

- @page定制错误页面

  ```jsp
  <%--定制错误页面--%>
  <%@page errorPage="500.jsp" %>   <%--这一行就是jsp指令--%>
  <%--当然页可以修改web.xml--%>
  ```

- @include

  ```jsp
  <%--也可以用jsp标签实现--%>
  <%@include file="../common/header.jsp"%>   
  <h1>网页主体</h1>
  <%@include file="../common/footer.jsp"%>
  <%--此种方式会将引用页面的内容直接拿过来，命名空间相同，同名变量会冲突--%>
  <%--jsp标签只是静态引用，一般用jsp标签--%>
  ```

### 4. JSP 9大内置对象

- PageContext、Request、Response、Session、Application（ServletContext）、config（ServletConfig）、out、page、exception

- 区别

  ```java
  pageContext.setAttribute("name1","nnk1");  //只在一个页面有效
  request.setAttribute("name2","nnk2");         //只在一次请求中有效，请求转发时会携带
  session.setAttribute("name3","nnk3");           //只在一次会话中有效
  application.setAttribute("name4","nnk4");   //只在服务器中有效，服务器不关一直有效
  //四个作用域从上往下依次增加，寻找变量从上往下找（类似双亲委派机制）
  ```

- 请求转发

  ```java
  pageContext.forward("/index.jsp");
  ```

### 5. EL表达式

- 用途：获取数据，执行运算，获取web开发常用对象

### 6. JSP标签和JSTL标签

- jsp标签

  ```jsp
  <%--携带参数的请求转发--%>
  <jsp:forward page="jsp4.jsp">
      <jsp:param name="name" value="nnk"/>
      <jsp:param name="age" value="14"/>
  </jsp:forward>
  ```

  ```jsp
  <%--取出参数--%>
  <%=request.getParameter("name")%>
  <%=request.getParameter("age")%>  
  ```

- JSTL：JSP标准标签库

- 引用JSTL

  ```jsp
  <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
  ```

### 7. JavaBean

- JavaBean要求：

  - 类必须是具体的、公共的
  - 必须要有无参构造
  - 所以属性都有对应的get/set方法

- 一般用来和数据库的字段做映射（ORM）

  | 数据库 | JavaBean |
  | :----: | :------: |
  |   表   |    类    |
  |  字段  |   属性   |
  | 行记录 |   对象   |

## 5. MVC

### 1. MVC

- Model模型、View视图、Controller控制器

- Model：负责各个功能的实现（如登录、增加、删除功能），用JavaBean实现

  View：展示数据，提供交互

  Controller：接收请求并转发给Model处理，处理完毕将数据交给View

### 2. 三层架构

- MVC是一种设计模式，实际使用的是软件架构是三层架构：

  表现层（UI）(web层)、业务逻辑层（BLL）(service层)、数据访问层（DAL）(dao层) ，再加上实体类库（Model）

- MVC三层架构

  |    MVC     |              三层架构              |                功能                 |
  | :--------: | :--------------------------------: | :---------------------------------: |
  |   Model    | service层，dao层，实体类库(数据库) |        业务处理，数据持久化         |
  |    View    |         表现层(前台jsp等)          |         展示数据，发起请求          |
  | Coltroller |       表现层(后台Servlet等)        | 接收请求，转发给Model，控制视图跳转 |

### 3. 过滤器

- 用来过滤网站的数据（处理乱码，登录验证等）

- 一个简单的Filter，用于过滤中文乱码

  ```java
  public class CharacterEncodingFilter implements Filter {
      @Override
      public void init(FilterConfig filterConfig) throws ServletException {
          //web服务器启动时就会初始化
          System.out.println("CharacterEncodingFilter正在初始化");
      }
  
      @Override
      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
          servletResponse.setCharacterEncoding("utf-8");
          servletRequest.setCharacterEncoding("utf-8");
          servletResponse.setContentType("text/html;charset=utf-8");
          System.out.println("执行前");
          filterChain.doFilter(servletRequest,servletResponse);//调用下一个Filter，不写则到此为止
          System.out.println("执行后");
      }
  
      @Override
      public void destroy() {
          //web服务器关闭时销毁
          System.out.println("CharacterEncodingFilter正在销毁");
      }
  }
  ```

  web.xml

  ```xml
      <filter>
          <filter-name>CharacterEncodingFilter</filter-name>
          <filter-class>nnk.pininkara.servlet.CharacterEncodingFilter</filter-class>
      </filter>
      <filter-mapping>
          <filter-name>CharacterEncodingFilter</filter-name>
          <url-pattern>/*</url-pattern>
      </filter-mapping>
  ```
  
- 登录验证实例

  ```java
  //拦截器，也可以用上面的xml注册
  @WebFilter(filterName = "loginFilter",urlPatterns = "/success.jsp")
  public class LoginFilter implements Filter {
      @Override
      public void init(FilterConfig filterConfig) throws ServletException {    }
      @Override
      public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
          //向下转型
          HttpServletRequest request = (HttpServletRequest) servletRequest;
          HttpServletResponse response=(HttpServletResponse)servletResponse;
          if (request.getSession().getAttribute("USER_SESSION")==null){
              response.sendRedirect("/ser01/noLogin.jsp");//重定向
          }
          filterChain.doFilter(servletRequest,servletResponse);
      }
      @Override
      public void destroy() {    }
  }
  ```

### 4. 监听器

- JavaWeb提供了非常多的监听器

- 一个简单的监听器实例，用于检测在线人数

  ```java
  public class OnlineCounterListener implements HttpSessionListener {
      //创建session监听，每当session被创建就触发
      @Override
      public void sessionCreated(HttpSessionEvent se) {
          ServletContext context=se.getSession().getServletContext();
          Integer onlineCount=(Integer) context.getAttribute("onlineCount");
  
          if (onlineCount == null) {
              onlineCount= 1;
          }else {
              int count= onlineCount;
              onlineCount=count+1;
          }
  
          context.setAttribute("onlineCount",onlineCount);
      }
  
      //每当session被销毁就触发
      @Override
      public void sessionDestroyed(HttpSessionEvent se) {
          ServletContext context=se.getSession().getServletContext();
          Integer onlineCount=(Integer) context.getAttribute("onlineCount");
  
          if (onlineCount == null) {
              onlineCount= 0;
          }else {
              int count= onlineCount;
              onlineCount=count-1;
          }
  
          context.setAttribute("onlineCount",onlineCount);
      }
  }
  ```

  web.xml

  ```xml
  <listener>
          <listener-class>nnk.pininkara.servlet.OnlineCounterListener</listener-class>
  </listener>
  ```

### 5. JDBC

- 参见[11.7](#11.7)

## 6. Ajax

### 1. Ajax简介

- Asynchronous Javascript And XML（异步JavaScript和XML）
- 能在无需重新加载整个网页的情况下更新部分网页内容
- 不是一种编程语言，而是一种用于创建更好更快以及交互性更强的web应用程序技术
- 此处使用jQuery实现Ajax

### 2. jQuery实现Ajax

- 默认使用get请求

## 7. 实战

### 1. 超市订单管理系统(smbms)项目搭建

- 后略

## 8. 文件上传

### 1. 准备工作

- 导入依赖

  ```xml
  <dependency>
        <groupId>commons-io</groupId>
        <artifactId>commons-io</artifactId>
        <version>2.11.0</version>
  </dependency>
  <dependency>
        <groupId>commons-fileupload</groupId>
        <artifactId>commons-fileupload</artifactId>
        <version>1.4</version>
  </dependency>
  ```

- 注意事项：

  - 为保证安全，上传的文件应该放在外界无法直接访问的目录下，比如WEB-INF目录
  - 为防止文件覆盖，要给文件生成一个唯一的文件名
  - 要限制上传文件的最大值
  - 可以限制上传文件的类型

### 2. 通过表单上传文件

- 必须要在表单里添加类型`enctype="multipart/form-data"`
- get提交有大小限制，一般使用post

## 9. 邮件发送

### 1. 原理

- 发送邮件：SMTP协议；接收邮件：POP3协议

- 需导入依赖

  ```xml
  <dependency>
        <groupId>javax.mail</groupId>
        <artifactId>mail</artifactId>
        <version>1.4.7</version>
  </dependency>
  <dependency>
        <groupId>javax.activation</groupId>
        <artifactId>activation</artifactId>
        <version>1.1.1</version>
  </dependency>
  ```

### 2. 实例

```java
public class MailTest {
    public static void main(String[] args) throws Exception {
        Properties pro = new Properties();
        pro.setProperty("mail.host", "smtp.exmail.qq.com");
        pro.setProperty("mail.transport.protocol", "smtp");
        pro.setProperty("mail.smtp.auth", "true");

        //设置SSL加密
        MailSSLSocketFactory sslSocketFactory = new MailSSLSocketFactory();
        sslSocketFactory.setTrustAllHosts(true);
        pro.put("mail.smtp.ssl.enable", "true");
        pro.put("mail.smtp.socketFactory.class", "com.sun.mail.util.MailSSLSocketFactory");
        pro.put("mail.smtp.ssl.socketFactory", sslSocketFactory);

        //1.创建Session对象
        Session session = Session.getDefaultInstance(pro, new Authenticator() {
            @Override
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("111@111.com", "授权码");
            }
        });
        session.setDebug(true);

        //2.通过Session得到transport对象
        Transport transport = session.getTransport();
        //3.连接服务器
        transport.connect("smtp.exmail.qq.com", "111@111.com", "授权码");
        //4.创建邮件
        Message message = new MimeMessage(session);
        message.setFrom(new InternetAddress("ILoveYou@insight.com"));
        message.setRecipient(Message.RecipientType.TO, new InternetAddress("111@111.com"));
        message.setSubject("I love you nnk");
        message.setContent("<h1 style='color=red'>你好世界</h1>", "text/html;charset=utf-8");
        //5.发送邮件
        transport.sendMessage(message, message.getAllRecipients());
        //6.关闭连接
        transport.close();
    }
}
```

# 13. MyBatis

## 1. 初识MyBatis

### 1. MyBatis简介

- 一个持久层框架
- 参见[官方文档](https://mybatis.org/mybatis-3/zh/index.html)

### 2. 第一个MyBatis程序

1. 导入依赖

   ```xml
   <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
               <version>8.0.25</version>
   </dependency>
   
   <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis</artifactId>
               <version>3.5.7</version>
   </dependency>
   ```

2. 编写核心配置文件

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE configuration
           PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-config.dtd">
   <configuration>
       <environments default="development">
           <environment id="development">
               <transactionManager type="JDBC"/>
               <dataSource type="POOLED">
                   <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                   <property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>
                   <property name="username" value="root"/>
                   <property name="password" value="password"/>
               </dataSource>
           </environment>
       </environments>
       
       <!--记得要注册Mapper-->
       <mappers>
           <mapper resource="nnk/dao/userMapper.xml"/>
       </mappers>
       
   </configuration>
   ```

3. 从xml中构建SqlSessionFactory

   ```java
   static {
           try {
               String resource = "mybatis-config.xml";
               InputStream inputStream = Resources.getResourceAsStream(resource);
               SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
           } catch (IOException e) {
               e.printStackTrace();
           }
   
   }
   ```

4. 通过SqlSessionFactory获得SqlSession

   ```java
   public static SqlSession getSqlSession(){
           return sqlSessionFactory.openSession();
   }
   ```

5. 编写接口

   ```java
   public interface UserDao {
       @Select("select * from user") //如果不用xml，则为注解
       List<User> getUserList();
   }
   ```

6. 编写mapper.xml （也可以不用xml，用注解）

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE mapper
           PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
   <mapper namespace="nnk.dao.UserMapper"><!--绑定命名空间为Dao-->
       <select id="getUserList" resultType="nnk.pojo.User"><!--id为接口方法名，resultType为返回值类型-->
           select * from user
       </select>
   </mapper>
   ```

7. 编写测试

   ```java
   public class MyTest {
       @org.junit.Test
       public void test() {
           SqlSession sqlSession = MybatisUtils.getSqlSession();
           //方式一：getMapper
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           List<User> userList = mapper.getUserList();
           for (User user : userList) {
               System.out.println(user);
           }
           
           //方式二：不推荐
           List<User> list = sqlSession.selectList("nnk.dao.UserMapper.getUserList");
           for (User user : list) {
               System.out.println(user);
           }
           sqlSession.close();
   }
   ```

8. 解决maven资源导出问题

   ```xml
   <!--pom.xml-->
   <build>
           <resources>
               <!--设置正常情况的resources目录下的properties文件-->
               <resource>
                   <!--配置路径-->
                   <directory>src/main/resources</directory>
                   <includes>
                       <!--包含什么文件-->
                       <include>**/*.properties</include>
                       <include>**/*.xml</include>
                   </includes>
               </resource>
               <!--设置java路径的properties文件-->
               <resource>
                   <directory>src/main/java</directory>
                   <includes>
                       <include>**/*.properties</include>
                       <include>**/*.xml</include>
                   </includes>
               </resource>
           </resources>
       </build>
   ```

## 2. CRUD

### 1. Retrieve(select)

- 参数：

  - id：namespace中的方法名
  - resultType：sql语句的返回值类型
  - parameterType：参数类型

- 实例

  ```java
  //UserMapper.java
  //根据ID查询用户
  @Select("select * from user where id = #{id}")  //使用注解
  User getUserById(int id);
  ```
```
  
  ```java
  //测试类
  SqlSession sqlSession=MybatisUtils.getSqlSession();
  UserMapper mapper = sqlSession.getMapper(UserMapper.class);
  User user = mapper.getUserById(1);
  System.out.println(user);
sqlSession.close();
```

### 2. Create(insert)

- 实例

  ```java
  //UserMapper.java
  //插入用户
  int addUser(User user);
  ```

    ```xml
  <!--UserMapper.xml--> 
  <!--对象中的属性可以直接使用-->
  <insert id="addUser" parameterType="nnk.pojo.User">
          insert into user (id,name,pwd) value (#{id},#{name},#{pwd})
  </insert>
    ```

    ```java
  //测试类
  SqlSession sqlSession=MybatisUtils.getSqlSession();
  UserMapper mapper = sqlSession.getMapper(UserMapper.class);
  mapper.addUser(new User(4,"关羽","246161"));
  sqlSession.commit();  //增删改需要提交事务
  sqlSession.close();
    ```

### 3. Update

- 实例

  ```java
  //UserMapper.java
  //修改用户
  int updateUser(User user);
  ```

    ```xml
  <!--UserMapper.xml--> 
  <!--对象中的属性可以直接使用-->
  <update id="updateUser" parameterType="nnk.pojo.User">
          update user
          set name = #{name}, pwd=#{pwd}
          where id = #{id};
</update>
    ```
  
    ```java
  //测试类
  SqlSession sqlSession=MybatisUtils.getSqlSession();
  UserMapper mapper = sqlSession.getMapper(UserMapper.class);
  mapper.updateUser(new User(4,"刘备","111111"));
  sqlSession.commit();
  sqlSession.close();
    ```

### 4. Delete

- 实例

  ```java
  //UserMapper.java
  //删除用户
  int deleteUser(int id);
  ```

    ```xml
  <!--UserMapper.xml--> 
  <!--对象中的属性可以直接使用-->
  <delete id="deleteUser" parameterType="int">
          delete
          from user
          where id= #{id};
</delete>
    ```
  
    ```java
  //测试类
  SqlSession sqlSession=MybatisUtils.getSqlSession();
  UserMapper mapper = sqlSession.getMapper(UserMapper.class);
  mapper.deleteUser(4);
  sqlSession.commit();
  sqlSession.close();
    ```

### 5. Map

- 假设实体类或者数据库中的表字段过多，可以使用map，避免新建对象过于繁琐

- 实例

  ```java
  @Insert("insert into user (id,name,pwd) values(#{id},#{name},#{pwd})")
  int addUser2(Map<String,Object> map);
  ```

  ```java
  SqlSession sqlSession = MybatisUtils.getSqlSession();
      UserMapper mapper = sqlSession.getMapper(UserMapper.class);
  
      HashMap<String, Object> map = new HashMap<>();
      map.put("id", 6);
      map.put("name", "黄忠");
      map.put("pwd", "asdq24");
  
      mapper.addUser2(map);
      sqlSession.commit();
      sqlSession.close();
  ```

- map传值#{}中对应map的key(因此可以不用和表中对应)；而对象传值需要一个完整的对象，#{}中对应对象属性名

### 6. 模糊查询

- 方式一：在java中传递通配符

  ```java
  //模糊查询
  @Select("select * from user where name like #{value}")
  List<User> getUserLike(String value);
  
  SqlSession sqlSession = MybatisUtils.getSqlSession();
  UserMapper mapper = sqlSession.getMapper(UserMapper.class);
  List<User> list = mapper.getUserLike("%李%");
  for (User user : list) {
          System.out.println(user);
  }
  sqlSession.commit();
  sqlSession.close();
  ```

- 方式二：在sql中传递通配符

  ```xml
  <select id="getUserLike" resultType="nnk.pojo.User">
          select *
          from user
          where name like "%"#{value}"%";
  </select>
  ```

- 无论哪种方法都需注意sql注入

## 3. 配置解析

### 1. 配置简介

- 配置文件为mybatis-config.xml
- 配置文档的顶层结构如下：
  - configuration（配置）
    - properties（属性）
    - settings（设置）
    - typeAliases（类型别名）
    - typeHandlers（类型处理器）
    - objectFactory（对象工厂）
    - plugins（插件）
    - environments（环境配置）
      - environment（环境变量）
      - transactionManager（事务管理器）
      - dataSource（数据源）
    - databaseIdProvider（数据库厂商标识）
    - mappers（映射器）

### 2. environments

- 切换环境

  ```xml
  <environments default="development">   <!--这里写的是哪个就用哪个-->
          <environment id="development">   <!--环境1-->
              <transactionManager type="JDBC"/> <!--事务管理器-->
              <dataSource type="POOLED">  <!--数据源-->
                  <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                  <property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>
                  <property name="username" value="root"/>
                  <property name="password" value="password"/>
              </dataSource>
          </environment>
      
          <environment id="development">  <!--环境2-->
          </environment>
  </environments>
  ```

- 事务管理器：

  - JDBC(默认)：这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域
  - MANAGED：这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为

- 数据源：

  - UNPOOLED：每次请求时打开和关闭连接
  - POOLED(默认)：利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。
  - JNDI：为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用

### 3. properties

- 属性可以在外部进行配置，并可以进行动态替换。既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置

  ```xml
  <properties resource="org/mybatis/example/config.properties">
            <property name="username" value="dev_user"/>
            <property name="password" value="F2Fa3!33TYyg"/>
  </properties>
  
  <!--设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值-->
  <dataSource type="POOLED">
            <property name="driver" value="${driver}"/>
            <property name="url" value="${url}"/>
            <property name="username" value="${username}"/>
            <property name="password" value="${password}"/>
  </dataSource>
  ```

- 外部配置的优先级更高

### 4. 别名

- 类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写

  ```xml
  <typeAliases>
            <typeAlias alias="Author" type="domain.blog.Author"/>
            <typeAlias alias="Blog" type="domain.blog.Blog"/>
  </typeAliases>
  ```

  当这样配置时，`Blog` 可以用在任何使用 `domain.blog.Blog` 的地方。

- 别名也可以指定包名

  ```xml
  <typeAliases>
            <package name="domain.blog"/>
  </typeAliases>
  ```

  在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名或类名来作为它的别名。 比如 `domain.blog.Author` 的别名为 `author`或`Author`

- 也可以使用注解配置别名

  ```java
  @Alias("author")
  public class Author {
      ...
  }
  ```

- 优先级：注解>自定义配置>类名

### 5. 设置

- MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为

- 常用设置

  |       设置名       |                             描述                             |   有效值   | 默认值 |
  | :----------------: | :----------------------------------------------------------: | :--------: | :----: |
  |    cacheEnabled    |    全局性地开启或关闭所有映射器配置文件中已配置的任何缓存    | true false |  true  |
  | lazyLoadingEnabled | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 | true false | false  |
  |      logImpl       |    指定 MyBatis 所用日志的具体实现，未指定时将自动查找。     |   见下方   | 未设置 |

  - logImpl默认值：SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING

- 参考实例

  ```xml
  <settings>
            <setting name="cacheEnabled" value="true"/>
            <setting name="lazyLoadingEnabled" value="true"/>
  </settings>
  ```

### 6. 插件

- MyBaits-Plus等

### 7. 映射器

- 需要告诉 MyBatis 到哪里去找到sql语句，主要有四种方式

- 使用相对于类路径的资源引用（推荐）

  ```xml
  <mappers>
            <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
            <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
  </mappers>
  ```

- 使用完全限定资源定位符（URL）（不推荐）

  ```xml
  <mappers>
            <mapper url="file:///var/mappers/AuthorMapper.xml"/>
            <mapper url="file:///var/mappers/BlogMapper.xml"/>
  </mappers>
  ```

- 使用映射器接口实现类的完全限定类名

  ```xml
  <mappers>
            <mapper class="org.mybatis.builder.AuthorMapper"/>
            <mapper class="org.mybatis.builder.BlogMapper"/>
  </mappers>
  ```

  - 注意：此种方式接口和Mapper.xml必须同名且在同一个包下

- 将包内的映射器接口实现全部注册为映射器

  ```xml
  <mappers>
            <package name="org.mybatis.builder"/>
  </mappers>
  ```

  - 注意点同上

### 8. 作用域和生命周期

- 错误的作用域和生命周期会导致严重的并发问题
- SqlSessionFactoryBuilder：局部变量，用于创建SqlSessionFactory，创建完就不需要了
- SqlSessionFactory：可以理解为数据库连接池， 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例
- SqlSession：连接到连接池的一个请求，需要开启和关闭，不是线程安全的，不可以被共享，因此最近作用域是在方法内，用完即关

### 9. resultMap结果集映射

- 实例

  ```xml
  <resultMap id="userMap" type="nnk.pojo.User">
      <!--column表示数据库中的字段，property为实体类中的属性-->
          <result column="id" property="id"/>
          <result column="pwd" property="password"/>
      </resultMap>
  ```

## 4. 日志

### 1. 日志工厂

- MyBatis内置了许多日志工厂：SLF4J | LOG4J(deprecated since 3.5.9) | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING 

### 2. 标准日志

- STDOUT_LOGGING

- 实例

  > Opening JDBC Connection
  > Created connection 945834881.
  > Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@38604b81]

### 3. Log4j

## 5. 分页

### 1. limit

- 语法

  ```sql
  select * form user limit 0,2;
  ```

- 实例

  ```java
  //分页
  List<User> getUserByLimit(Map<String,Integer> map);
  ```

  ```xml
   <select id="getUserByLimit" parameterType="map" resultType="nnk.pojo.User">
          select * from user limit #{startIndex},#{pageSize}
  </select>
  ```

  ```java
  SqlSession sqlSession = MybatisUtils.getSqlSession();
  UserMapper mapper = sqlSession.getMapper(UserMapper.class);
  HashMap<String, Integer> map = new HashMap<>();
  map.put("startIndex",0);
  map.put("pageSize",2);
  List<User> list = mapper.getUserByLimit(map);
  for (User user : list) {
      System.out.println(user);
  }
  sqlSession.commit();
  sqlSession.close();
  ```

### 2. RowBounds

- 实例

  ```java
  //分页2
  @Select("select * from user")
  List<User> getUserByRowBounds();
  ```

  ```java
  SqlSession sqlSession = MybatisUtils.getSqlSession();
          //通过java实现分页
          RowBounds rowBounds = new RowBounds(0, 2);
          List<User> list = sqlSession.selectList("nnk.dao.UserMapper.getUserByRowBounds",null,rowBounds);
          for (User user : list) {
              System.out.println(user);
          }
          sqlSession.commit();
          sqlSession.close();
  ```

### 3. 分页插件

- PageHelper

## 6. 使用注解开发

### 1. 注解绑定Mapper

- 接口

  ```java
  public interface UserMapper2 {
          @Select("select * from user")
          List<User> getUsers();
  }
  ```

- 配置文件

  ```xml
  <mappers>
          <mapper resource="nnk/dao/userMapper.xml"/>
          <mapper class="nnk.dao.UserMapper2"/>
  </mappers>
  ```

- 使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果需要做一些很复杂的操作，最好用 XML 来映射语句

### 2. 注解CRUD

- 全局自动提交

  ```java
  public static SqlSession getSqlSession(){
          return sqlSessionFactory.openSession(true);//true为自动提交，默认为false
  }
  ```

- 查询

  ```java
  //方法有多个参数，每个参数前必须加@Param注解
  @Select("select * from user where id=#{id}")//以@Param注解的参数名为准
  User getUserById(@Param("id") int id2, @Param("name") String name);
  ```

- 增加

  ```java
  @Select("insert into user(id,name,pwd) value(#{id},#{name},#{pwd})")
  int addUser(User user);
  ```

### 3. @Param注解

- 基本类型和String类型的参数都需要，引用类型参数不需要
- 如果只用一个基本类型，可不加，建议加
- sql引用的参数名以@Param注解为准

### 4. #{}和${}

- ${}只能配合@Param注解，原样输出，不会预编译，有sql注入的风险
- #{}会预编译为?，起到一个占位符的作用

## 7. 复杂查询

### 1. 联表查询

- 直接查询会导致被引用对象为null

  ```java
  //学生类
  public class Student {
      private int id;
      private String name;
      //学生需要关联一个老师
      private Teacher teacher;
  }
  ```

  > select * from student 执行结果
  >
  > Student(id=1, name=小明, teacher=null)
  > Student(id=2, name=小红, teacher=null)
  > Student(id=3, name=小张, teacher=null)
  > Student(id=4, name=小李, teacher=null)
  > Student(id=5, name=小王, teacher=null)
  >
  > select s.id,s.name,t.name from student s ,teacher t where s.tid=t.id;执行结果也一样

- 方式一：使用resultMap

  ```xml
  <select id="getStudent" resultMap="StudentTeacher">
          select * from student;
  </select>
  
  <resultMap id="StudentTeacher" type="Student">
          <result property="id" column="id"/>
          <result property="name" column="name"/>
          <!--复杂属性，需要单独处理-->
          <!--对象：association；集合：collection-->
          <association property="teacher" column="tid" javaType="Teacher" select="getTeacher"/>   <!--相当于进行一次子查询-->
  </resultMap>
  
  <select id="getTeacher" resultType="Teacher">
          select * from teacher where id=#{id}
  </select>
  ```

- 1











































